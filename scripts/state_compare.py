#!/usr/bin/env python3
# Copyright 2023 Volodymyr Melnyk
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
PKI State Comparison Script

This script compares two PKI state JSON dumps generated by state_dump.py
and displays the differences in a unified diff-style format with highlighting.
It recursively compares the data structures and shows what changed between
two PKI state snapshots.

Usage:
    python scripts/state_compare.py <before.json> <after.json>
"""

import argparse
import json
import sys
from typing import Dict, Any, List, Tuple, Union
from pathlib import Path


class Colors:
    """ANSI color codes for terminal output"""
    RESET = '\033[0m'
    BOLD = '\033[1m'
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'


class StateComparator:
    """Main class for comparing PKI state dumps"""
    
    def __init__(self, use_colors: bool = True):
        self.use_colors = use_colors
        self.differences = []
        self.change_markers = {}  # path -> change type for tree display
        
    def colorize(self, text: str, color: str) -> str:
        """Apply color to text if colors are enabled"""
        if not self.use_colors:
            return text
        return f"{color}{text}{Colors.RESET}"
    
    def load_json_file(self, file_path: str) -> Dict[str, Any]:
        """Load and parse JSON file"""
        try:
            with open(file_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"Error: File '{file_path}' not found", file=sys.stderr)
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"Error: Invalid JSON in '{file_path}': {e}", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error: Failed to read '{file_path}': {e}", file=sys.stderr)
            sys.exit(1)
    
    def get_path_string(self, path: List[str]) -> str:
        """Convert path list to a readable string"""
        if not path:
            return "root"
        return " -> ".join(path)
    
    def compare_values(self, old_val: Any, new_val: Any, path: List[str]) -> None:
        """Compare two values and record differences"""
        path_str = self.get_path_string(path)
        
        if old_val == new_val:
            return
            
        # Handle different types
        if type(old_val) != type(new_val):
            diff = {
                'type': 'type_change',
                'path': path_str,
                'old_type': type(old_val).__name__,
                'new_type': type(new_val).__name__,
                'old_value': old_val,
                'new_value': new_val
            }
            self.differences.append(diff)
            self.change_markers[path_str] = 'changed'
            return
        
        # Handle dictionaries recursively
        if isinstance(old_val, dict) and isinstance(new_val, dict):
            self.compare_dicts(old_val, new_val, path)
            return
            
        # Handle lists recursively
        if isinstance(old_val, list) and isinstance(new_val, list):
            self.compare_lists(old_val, new_val, path)
            return
        
        # Handle primitive value changes
        diff = {
            'type': 'value_change',
            'path': path_str,
            'old_value': old_val,
            'new_value': new_val
        }
        self.differences.append(diff)
        self.change_markers[path_str] = 'changed'
    
    def compare_dicts(self, old_dict: Dict[str, Any], new_dict: Dict[str, Any], path: List[str]) -> None:
        """Compare two dictionaries recursively"""
        all_keys = set(old_dict.keys()) | set(new_dict.keys())
        
        for key in sorted(all_keys):
            current_path = path + [key]
            current_path_str = self.get_path_string(current_path)
            
            if key not in old_dict:
                # Key was added
                diff = {
                    'type': 'added',
                    'path': current_path_str,
                    'value': new_dict[key]
                }
                self.differences.append(diff)
                self.change_markers[current_path_str] = 'added'
            elif key not in new_dict:
                # Key was removed
                diff = {
                    'type': 'removed',
                    'path': current_path_str,
                    'value': old_dict[key]
                }
                self.differences.append(diff)
                self.change_markers[current_path_str] = 'removed'
            else:
                # Key exists in both, compare values
                self.compare_values(old_dict[key], new_dict[key], current_path)
    
    def compare_lists(self, old_list: List[Any], new_list: List[Any], path: List[str]) -> None:
        """Compare two lists"""
        # For simplicity, we'll compare lists element by element
        # This could be enhanced with more sophisticated diff algorithms
        max_len = max(len(old_list), len(new_list))
        
        for i in range(max_len):
            current_path = path + [f"[{i}]"]
            
            if i >= len(old_list):
                # Element was added
                self.differences.append({
                    'type': 'added',
                    'path': self.get_path_string(current_path),
                    'value': new_list[i]
                })
            elif i >= len(new_list):
                # Element was removed
                self.differences.append({
                    'type': 'removed',
                    'path': self.get_path_string(current_path),
                    'value': old_list[i]
                })
            else:
                # Compare elements
                self.compare_values(old_list[i], new_list[i], current_path)
    
    def format_value(self, value: Any, max_length: int = 100) -> str:
        """Format a value for display, truncating if too long"""
        if isinstance(value, (dict, list)):
            json_str = json.dumps(value, separators=(',', ':'))
            if len(json_str) > max_length:
                return json_str[:max_length] + "..."
            return json_str
        else:
            str_val = str(value)
            if len(str_val) > max_length:
                return str_val[:max_length] + "..."
            return str_val
    
    def print_header(self, before_file: str, after_file: str) -> None:
        """Print comparison header"""
        print("PKI State Comparison")
        print(self.colorize(f"Before: {before_file}", Colors.YELLOW + Colors.BOLD))
        print(self.colorize(f"After:  {after_file}", Colors.WHITE + Colors.BOLD))
        print()
    
    
    
    def count_recursive_cas(self, authorities: Dict[str, Any], change_type: str) -> tuple:
        """Recursively count CAs and their components in a hierarchical structure"""
        total_cas = 0
        total_certs = 0
        total_keys = 0
        total_csrs = 0
        
        for ca_name, ca_data in authorities.items():
            # Count this CA
            total_cas += 1
            
            # Count CA's own certificate, private key, and CSR
            if ca_data.get('own_certificate'):
                total_certs += 1
            if ca_data.get('own_private_key'):
                total_keys += 1
            if ca_data.get('own_certificate_signing_request'):
                total_csrs += 1
            
            # Count issued certificates for this CA
            issued_certs = ca_data.get('issued_certificates', {})
            for cert_name, cert_data in issued_certs.items():
                if cert_data.get('certificate'):
                    total_certs += 1
                if cert_data.get('private_key'):
                    total_keys += 1
                if cert_data.get('certificate_signing_request'):
                    total_csrs += 1
            
            # Recursively count child CAs
            child_authorities = ca_data.get('authorities', {})
            if child_authorities:
                child_cas, child_certs, child_keys, child_csrs = self.count_recursive_cas(child_authorities, change_type)
                total_cas += child_cas
                total_certs += child_certs
                total_keys += child_keys
                total_csrs += child_csrs
        
        return total_cas, total_certs, total_keys, total_csrs

    def print_summary(self, after_state: Dict[str, Any] = None) -> None:
        """Print a summary of changes"""
        if not self.differences:
            return
            
        # Count different types of changes by PKI object type
        pki_counts = {
            'certificate_authorities': {'added': 0, 'removed': 0, 'changed': 0},
            'certificates': {'added': 0, 'removed': 0, 'changed': 0},
            'private_keys': {'added': 0, 'removed': 0, 'changed': 0},
            'csrs': {'added': 0, 'removed': 0, 'changed': 0},
            'other': {'added': 0, 'removed': 0, 'changed': 0}
        }
        
        for diff in self.differences:
            diff_type = diff['type']
            path = diff['path']
            
            # Map change types
            change_type = 'changed'  # default for value_change, type_change
            if diff_type == 'added':
                change_type = 'added'
            elif diff_type == 'removed':
                change_type = 'removed'
            
            # Determine PKI object type from path
            if path.startswith('authorities ->') and path.count(' -> ') == 1:
                # This is a CA-level change (e.g., "authorities -> root")
                pki_counts['certificate_authorities'][change_type] += 1
                
                # When a CA is added/removed, also count its components
                if change_type in ['added', 'removed'] and after_state:
                    ca_name = path.split(' -> ')[1]
                    
                    # Look for this CA's data in the appropriate state
                    try:
                        ca_data = after_state.get('authorities', {}).get(ca_name, {})
                        
                        # Count CA's own certificate and private key
                        if ca_data.get('own_certificate'):
                            pki_counts['certificates'][change_type] += 1
                        if ca_data.get('own_private_key'):
                            pki_counts['private_keys'][change_type] += 1
                        if ca_data.get('own_certificate_signing_request'):
                            pki_counts['csrs'][change_type] += 1
                        
                        # Count all issued certificates, private keys, and CSRs
                        issued_certs = ca_data.get('issued_certificates', {})
                        for cert_name, cert_data in issued_certs.items():
                            if cert_data.get('certificate'):
                                pki_counts['certificates'][change_type] += 1
                            if cert_data.get('private_key'):
                                pki_counts['private_keys'][change_type] += 1
                            if cert_data.get('certificate_signing_request'):
                                pki_counts['csrs'][change_type] += 1
                        
                        # Recursively count child CAs and their components
                        child_authorities = ca_data.get('authorities', {})
                        if child_authorities:
                            child_ca_count, child_cert_count, child_key_count, child_csr_count = self.count_recursive_cas(child_authorities, change_type)
                            
                            pki_counts['certificate_authorities'][change_type] += child_ca_count
                            pki_counts['certificates'][change_type] += child_cert_count
                            pki_counts['private_keys'][change_type] += child_key_count
                            pki_counts['csrs'][change_type] += child_csr_count
                        
                    except Exception as e:
                        # Fallback: assume CA has at least its own cert + private key
                        pki_counts['certificates'][change_type] += 1
                        pki_counts['private_keys'][change_type] += 1
                    
            elif 'own_certificate' in path or ('certificate' in path and 'certificate_signing_request' not in path):
                pki_counts['certificates'][change_type] += 1
            elif 'own_private_key' in path or 'private_key' in path:
                pki_counts['private_keys'][change_type] += 1
            elif 'own_certificate_signing_request' in path or 'certificate_signing_request' in path:
                pki_counts['csrs'][change_type] += 1
            else:
                pki_counts['other'][change_type] += 1
        
        print(self.colorize("Summary:", Colors.BOLD + Colors.BLUE))
        
        # Print counts for each PKI object type
        object_labels = {
            'certificate_authorities': 'Certificate Authorities',
            'certificates': 'Certificates',
            'private_keys': 'Private Keys', 
            'csrs': 'Certificate Signing Requests',
            'other': 'Other Changes'
        }
        
        total_changes = 0
        for obj_type, label in object_labels.items():
            counts = pki_counts[obj_type]
            obj_total = sum(counts.values())
            if obj_total > 0:
                parts = []
                if counts['added'] > 0:
                    parts.append(self.colorize(f"+{counts['added']}", Colors.GREEN))
                if counts['removed'] > 0:
                    parts.append(self.colorize(f"-{counts['removed']}", Colors.RED))
                if counts['changed'] > 0:
                    parts.append(self.colorize(f"~{counts['changed']}", Colors.YELLOW))
                
                change_summary = " ".join(parts)
                print(f"  {label}: {obj_total} ({change_summary})")
                total_changes += obj_total
        
        print(self.colorize(f"  Total changes: {total_changes}", Colors.BOLD))
    
    def get_change_marker_for_path(self, path: str) -> str:
        """Get the change marker symbol for a given path"""
        # First check if this exact path has a change
        change_type = self.change_markers.get(path, 'unchanged')
        if change_type != 'unchanged':
            if change_type == 'added':
                return '+'
            elif change_type == 'removed':
                return '-'
            elif change_type == 'changed':
                return '~'
        
        # If no direct change, check if any parent path was added or removed
        # This ensures child elements are marked when their parent is added/removed
        path_parts = path.split(' -> ')
        for i in range(1, len(path_parts)):
            parent_path = ' -> '.join(path_parts[:i])
            parent_change = self.change_markers.get(parent_path, 'unchanged')
            if parent_change == 'added':
                return '+'
            elif parent_change == 'removed':
                return '-'
        
        # Return equals sign for unchanged items
        return '='
    
    def get_change_color_for_path(self, path: str) -> str:
        """Get the color for a given path based on its change status"""
        # First check if this exact path has a change
        change_type = self.change_markers.get(path, 'unchanged')
        if change_type != 'unchanged':
            if change_type == 'added':
                return Colors.GREEN
            elif change_type == 'removed':
                return Colors.RED
            elif change_type == 'changed':
                return Colors.YELLOW
        
        # If no direct change, check if any parent path was added or removed
        path_parts = path.split(' -> ')
        for i in range(1, len(path_parts)):
            parent_path = ' -> '.join(path_parts[:i])
            parent_change = self.change_markers.get(parent_path, 'unchanged')
            if parent_change == 'added':
                return Colors.GREEN
            elif parent_change == 'removed':
                return Colors.RED
        
        return Colors.RESET
    
    def format_certificate_info(self, cert_info: Dict[str, Any]) -> str:
        """Format certificate information for display"""
        if not cert_info or 'error' in cert_info:
            return f"[ERROR: {cert_info.get('error', 'Unknown error')}]"
        
        subject = cert_info.get('subject', 'Unknown Subject')
        # Extract CN from the subject string
        if 'CN=' in subject:
            cn_start = subject.find('CN=') + 3
            cn_end = subject.find(',', cn_start)
            if cn_end == -1:
                cn_end = subject.find('>', cn_start)
            cn = subject[cn_start:cn_end] if cn_end > cn_start else subject[cn_start:]
        else:
            cn = 'No CN'
        
        serial = cert_info.get('serial_number', 'Unknown Serial')
        not_after = cert_info.get('not_valid_after', '')
        validity_status = ""
        if not_after:
            # Simplify the date format and check validity
            try:
                from datetime import datetime, timezone
                dt = datetime.fromisoformat(not_after.replace('Z', '+00:00'))
                not_after_str = dt.strftime('%Y-%m-%d')
                
                # Check if certificate is expiring soon or expired
                now = datetime.now(timezone.utc)
                days_until_expiry = (dt - now).days
                
                if days_until_expiry < 0:
                    validity_status = " [EXPIRED]"
                elif days_until_expiry <= 30:
                    validity_status = f" [EXPIRES IN {days_until_expiry} DAYS]"
                    
                not_after = not_after_str
            except:
                pass
        
        # Add certificate type information
        cert_type_info = ""
        cert_type = cert_info.get('cert_type', '')
        is_self_signed = cert_info.get('is_self_signed', False)
        if cert_type:
            if is_self_signed:
                cert_type_info = f", {cert_type.upper()} [SELF-SIGNED]"
            else:
                cert_type_info = f", {cert_type.upper()}"
        
        # Add key information
        key_info = ""
        key_size = cert_info.get('public_key_size')
        sig_alg = cert_info.get('signature_algorithm', '')
        if key_size:
            key_info = f", {key_size}-bit"
        if sig_alg:
            key_info += f" {sig_alg}"
        
        # Add subject alternative names if available
        san_info = ""
        sans = cert_info.get('subject_alternative_names', [])
        if sans:
            san_count = len(sans)
            if san_count <= 3:
                san_info = f", SANs: {', '.join(sans)}"
            else:
                san_info = f", SANs: {', '.join(sans[:3])} (+{san_count-3} more)"
        
        # Add key usage information
        usage_info = ""
        key_usage = cert_info.get('key_usage', [])
        ext_key_usage = cert_info.get('extended_key_usage', [])
        
        usage_parts = []
        if key_usage:
            usage_parts.append(f"KeyUsage: {', '.join(key_usage)}")
        if ext_key_usage:
            usage_parts.append(f"ExtKeyUsage: {', '.join(ext_key_usage)}")
        if usage_parts:
            usage_info = f", {'; '.join(usage_parts)}"
        
        return f"{cn} (Serial: {serial[:8]}{'...' if len(serial) > 8 else ''}, Expires: {not_after}{validity_status}{cert_type_info}{key_info}{san_info}{usage_info})"
    
    
    
    
    def format_file_size(self, file_size: int) -> str:
        """Format file size in a human-readable way"""
        if file_size >= 1024:
            size_kb = file_size / 1024
            if size_kb >= 1024:
                size_mb = size_kb / 1024
                return f"{size_mb:.2f} MB ({file_size:,} bytes)"
            else:
                return f"{size_kb:.2f} KB ({file_size:,} bytes)"
        else:
            return f"{file_size} bytes"

    def format_datetime(self, datetime_str: str, with_days_remaining: bool = False) -> str:
        """Format datetime string consistently"""
        try:
            from datetime import datetime, timezone
            # Parse the datetime string
            if datetime_str.endswith('Z'):
                dt = datetime.fromisoformat(datetime_str.replace('Z', '+00:00'))
            elif '+' in datetime_str or datetime_str.endswith('UTC'):
                dt = datetime.fromisoformat(datetime_str.replace('Z', '+00:00'))
            else:
                # Assume naive datetime is UTC
                dt = datetime.fromisoformat(datetime_str)
                dt = dt.replace(tzinfo=timezone.utc)
            
            formatted = dt.strftime('%Y-%m-%d %H:%M:%S UTC')
            
            if with_days_remaining:
                now = datetime.now(timezone.utc)
                days_remaining = (dt - now).days
                if dt > now:
                    formatted += f" [expires in {days_remaining} days]"
                else:
                    formatted += " [EXPIRED]"
            
            return formatted
        except Exception as e:
            # Fallback formatting - preserve original behavior but log what went wrong
            fallback = datetime_str[:19] + ' UTC' if len(datetime_str) >= 19 else datetime_str + ' UTC'
            if with_days_remaining:
                fallback += " [DATE PARSE ERROR]"
            return fallback

    def extract_file_details(self, obj_info: Dict[str, Any]) -> List[Tuple[str, str]]:
        """Extract common file details (name, size, permissions, modified time)"""
        details = []
        
        file_path = obj_info.get('file', '')
        if file_path:
            import os
            details.append(('File Name', os.path.basename(file_path)))

            # File size
            file_size = obj_info.get('file_size')
            if file_size:
                details.append(('File Size', self.format_file_size(file_size)))
            
            # File permissions
            file_perms = obj_info.get('file_permissions')
            if file_perms:
                details.append(('File Permissions', file_perms))
            
            # Last modified time
            last_modified = obj_info.get('last_modified')
            if last_modified:
                details.append(('File Modified', self.format_datetime(last_modified)))
        
        return details

    def print_x509_name_tree(self, name_data: Dict[str, str], header: str, base_path: str, indent: str) -> None:
        """Print X.509 name (subject or issuer) in tree format"""
        if not name_data:
            return
        
        # Print name header
        print(f"{indent}├── {self.colorize(f'[:] {header}', Colors.BOLD + Colors.WHITE)}")
        name_indent = indent + "│   "
        
        # Standard order for displaying name components
        component_order = ['C', 'ST', 'L', 'O', 'OU', 'CN', 'emailAddress']
        displayed_components = []
        
        # First, display standard components in order
        for component in component_order:
            if component in name_data:
                displayed_components.append(component)
        
        # Then add any additional components not in the standard order
        for component in name_data:
            if component not in displayed_components:
                displayed_components.append(component)
        
        for i, component in enumerate(displayed_components):
            is_last = (i == len(displayed_components) - 1)
            branch = "└──" if is_last else "├──"
            
            value = name_data[component]
            component_path = f"{base_path} -> {header.lower()} -> {component}"
            detail_marker = self.get_change_marker_for_path(component_path)
            detail_color = self.get_change_color_for_path(component_path)
            
            detail_display = f"[{detail_marker}] {component}: {value}"
            if detail_marker in ['+', '-', '~']:
                detail_display = self.colorize(detail_display, detail_color)
            
            print(f"{name_indent}{branch} {detail_display}")

    def print_sans_tree(self, sans: List[str], base_path: str, indent: str) -> None:
        """Print Subject Alternative Names in tree format"""
        if not sans:
            return
        
        # Print SANs header
        print(f"{indent}├── {self.colorize('[:] SANs', Colors.BOLD + Colors.WHITE)}")
        sans_indent = indent + "│   "
        
        for i, san in enumerate(sans):
            is_last = (i == len(sans) - 1)
            branch = "└──" if is_last else "├──"
            
            san_path = f"{base_path} -> sans -> {i}"
            detail_marker = self.get_change_marker_for_path(san_path)
            detail_color = self.get_change_color_for_path(san_path)
            
            detail_display = f"[{detail_marker}] {san}"
            if detail_marker in ['+', '-', '~']:
                detail_display = self.colorize(detail_display, detail_color)
            
            print(f"{sans_indent}{branch} {detail_display}")

    def print_file_info_tree(self, obj_info: Dict[str, Any], base_path: str, indent: str) -> None:
        """Print file information as tree branches at the end of entity details"""
        file_path = obj_info.get('file', '')
        if not file_path:
            return
            
        import os
        filename = os.path.basename(file_path)
        
        # Print "File" as main branch with [:] marker (header style)
        # Headers always use [:] marker and white-bold color regardless of change status
        file_color = Colors.BOLD + Colors.WHITE
        file_display = f"[:] File"
        
        file_display = self.colorize(file_display, file_color)
        print(f"{indent}└──{file_display}")
        
        # Print file details as sub-branches
        file_details = []
        
        # File name
        file_details.append(('name', filename))
        
        # Full absolute path
        file_details.append(('path', file_path))
        
        # File size
        file_size = obj_info.get('file_size')
        if file_size is not None:
            file_details.append(('size', self.format_file_size(file_size)))
        
        # File permissions in octal format
        file_perms = obj_info.get('file_permissions')
        if file_perms:
            # Convert to octal format if it's not already
            if file_perms.startswith('0o') or file_perms.startswith('0'):
                octal_perms = file_perms
            else:
                # Assume it's a string like "rw-r--r--" and try to convert
                try:
                    # If it looks like Unix permissions, convert to octal
                    if len(file_perms) == 9 and all(c in 'rwx-' for c in file_perms):
                        octal_val = 0
                        for i, perm in enumerate(file_perms):
                            if perm != '-':
                                octal_val |= (1 << (8 - i))
                        octal_perms = f"0o{oct(octal_val)[2:]:0>3}"
                    else:
                        octal_perms = file_perms
                except:
                    octal_perms = file_perms
            file_details.append(('permissions', octal_perms))
        
        # Last modified time
        last_modified = obj_info.get('last_modified')
        if last_modified:
            file_details.append(('modified', self.format_datetime(last_modified)))
        
        # Print each detail as a sub-branch
        sub_indent = indent + "    "
        for i, (detail_type, detail_value) in enumerate(file_details):
            is_last_detail = (i == len(file_details) - 1)
            detail_path = f"{base_path} -> file -> {detail_type}"
            detail_marker = self.get_change_marker_for_path(detail_path)
            detail_color = self.get_change_color_for_path(detail_path)
            
            detail_display = f"[{detail_marker}] {detail_type.title()}: {detail_value}"
            if detail_marker in ['+', '-', '~']:
                detail_display = self.colorize(detail_display, detail_color)
            
            branch_symbol = "└──" if is_last_detail else "├──"
            print(f"{sub_indent}{branch_symbol}{detail_display}")

    def print_details_with_file_info(self, details: List[Tuple[str, str]], obj_info: Dict[str, Any], base_path: str, indent: str) -> None:
        """Print entity details followed by file information with correct tree structure"""
        has_file_info = bool(obj_info.get('file'))
        
        # Print regular details
        for i, (label, value) in enumerate(details):
            is_last_detail = (i == len(details) - 1)
            detail_path = f"{base_path} -> {label.lower().replace(' ', '_').replace('&', 'and')}"
            detail_marker = self.get_change_marker_for_path(detail_path)
            detail_color = self.get_change_color_for_path(detail_path)
            
            # If this is the last detail AND there's file info, use junction (├) not corner (└)
            if is_last_detail and has_file_info:
                branch = "├──"
            else:
                branch = "└──" if is_last_detail else "├──"
            
            detail_display = f"[{detail_marker}] {label}: {value}"
            
            if detail_marker in ['+', '-', '~']:
                detail_display = self.colorize(detail_display, detail_color)
            
            print(f"{indent}{branch}{detail_display}")
        
        # Print file information if it exists
        if has_file_info:
            self.print_file_info_tree(obj_info, base_path, indent)

    def print_details_tree(self, details: List[Tuple[str, str]], base_path: str, indent: str) -> None:
        """Print a list of details as tree sub-elements with proper formatting"""
        for i, (label, value) in enumerate(details):
            is_last = (i == len(details) - 1)
            detail_path = f"{base_path} -> {label.lower().replace(' ', '_').replace('&', 'and')}"
            detail_marker = self.get_change_marker_for_path(detail_path)
            detail_color = self.get_change_color_for_path(detail_path)
            
            branch = "└──" if is_last else "├──"
            detail_display = f"[{detail_marker}] {label}: {value}"
            
            if detail_marker in ['+', '-', '~']:
                detail_display = self.colorize(detail_display, detail_color)
            
            print(f"{indent}{branch}{detail_display}")

    def format_tree_item(self, marker: str, label: str, count: int = None) -> str:
        """Format a tree item with marker and optional count"""
        if count is not None:
            return f"[{marker}] {label} ({count})"
        else:
            return f"[{marker}] {label}"

    def get_tree_branch(self, indent: str, is_last: bool) -> Tuple[str, str]:
        """Get the appropriate tree branch symbols and next indent level"""
        if indent == "":
            branch = " ├──" if not is_last else " └──"
            next_indent = " │   " if not is_last else "     "
        else:
            branch = indent + ("├──" if not is_last else "└──")
            next_indent = indent + ("│   " if not is_last else "    ")
        return branch, next_indent

    def format_tree_node(self, path: str, label: str, color: str = None) -> str:
        """Format a tree node with marker and color"""
        marker = self.get_change_marker_for_path(path)
        node_color = self.get_change_color_for_path(path) if marker in ['+', '-', '~'] else (color or Colors.RESET)
        display = f"[{marker}] {label}"
        return self.colorize(display, node_color) if node_color != Colors.RESET else display

    def format_sub_header_node(self, path: str, label: str) -> str:
        """Format a sub-header node (Certificate, CSR, Private Key) with [:] marker and white-bold color"""
        # Headers always use [:] marker and white-bold color regardless of change status
        marker = ":"
        node_color = Colors.BOLD + Colors.WHITE
        
        display = f"[{marker}] {label}"
        return self.colorize(display, node_color)

    def print_tree_section(self, indent: str, is_last: bool, path: str, label: str, count: int = None, default_color: str = Colors.BOLD + Colors.WHITE):
        """Print a tree section header with formatting"""
        # Headers always use [:] marker and white-bold color regardless of change status
        section_color = Colors.BOLD + Colors.WHITE
        display = self.format_tree_item(":", label, count)
        
        branch = indent + ("└──" if is_last else "├──")
        print(f"{branch}{self.colorize(display, section_color)}")
        
        return indent + ("    " if is_last else "│   ")

    def process_sub_items(self, cert_data: Dict[str, Any], cert_path: str, cert_details_indent: str):
        """Process and display sub-items (certificate, CSR, private key) for an issued certificate"""
        sub_items = []
        cert_info = cert_data.get('certificate')
        csr_info = cert_data.get('certificate_signing_request')  
        private_key_info = cert_data.get('private_key')
        
        if cert_info:
            sub_items.append(('certificate', cert_info, 'Certificate'))
        if csr_info:
            sub_items.append(('csr', csr_info, 'Certificate Signing Request'))
        if private_key_info:
            sub_items.append(('private_key', private_key_info, 'Private Key'))

        for sub_idx, (sub_type, sub_data, sub_label) in enumerate(sub_items):
            is_last_sub = (sub_idx == len(sub_items) - 1)
            sub_path = f"{cert_path} -> {sub_type}"
            
            sub_display = self.format_sub_header_node(sub_path, sub_label)
            sub_branch = cert_details_indent + ("└──" if is_last_sub else "├──")
            print(f"{sub_branch}{sub_display}")
            
            # Print details as sub-sub-elements
            sub_detail_indent = cert_details_indent + ("    " if is_last_sub else "│   ")
            if sub_type == 'certificate':
                self.print_certificate_details(sub_data, sub_path, sub_detail_indent)
            elif sub_type == 'private_key':
                self.print_private_key_details(sub_data, sub_path, sub_detail_indent)
            elif sub_type == 'csr':
                self.print_csr_details(sub_data, sub_path, sub_detail_indent)

    def print_ca_sections(self, ca_data: Dict[str, Any], current_path: str, next_indent: str):
        """Print sections for a CA (certificate, private key, CSR, child authorities, issued certificates)"""
        own_cert = ca_data.get('own_certificate')
        own_key = ca_data.get('own_private_key')
        own_csr = ca_data.get('own_certificate_signing_request')
        issued_certs = ca_data.get('issued_certificates', {})
        child_authorities = ca_data.get('authorities', {})
        
        # Count and display sections - fix path names for consistency with original format
        sections = []
        if own_cert:
            sections.append(('own_certificate', own_cert, 'Certificate'))
        if own_csr:
            sections.append(('own_certificate_signing_request', own_csr, 'Certificate Signing Request'))
        if own_key:
            sections.append(('own_private_key', own_key, 'Private Key'))
        if child_authorities:
            sections.append(('authorities', child_authorities, 'Certificate Authorities'))
        if issued_certs:
            sections.append(('issued_certificates', issued_certs, 'Issued Certificates'))
        
        for section_idx, (section_type, section_data, section_label) in enumerate(sections):
            is_last_section = (section_idx == len(sections) - 1)
            section_path = f"{current_path} -> {section_type}"
            
            if section_type == 'authorities':
                section_indent = self.print_tree_section(next_indent, is_last_section, section_path, section_label, len(section_data))
                self.print_ca_tree(section_data, section_indent, True, section_path)
            elif section_type == 'issued_certificates':
                section_indent = self.print_tree_section(next_indent, is_last_section, section_path, section_label, len(section_data))
                self.print_issued_certificates(section_data, section_path, section_indent)
            else:
                # Individual items (certificate, key, csr) - use sub-header formatting
                section_display = self.format_sub_header_node(section_path, section_label)
                section_branch = next_indent + ("└──" if is_last_section else "├──")
                print(f"{section_branch}{section_display}")
                
                section_detail_indent = next_indent + ("    " if is_last_section else "│   ")
                if section_type == 'own_certificate':
                    self.print_certificate_details(section_data, section_path, section_detail_indent)
                elif section_type == 'own_private_key':
                    self.print_private_key_details(section_data, section_path, section_detail_indent)
                elif section_type == 'own_certificate_signing_request':
                    self.print_csr_details(section_data, section_path, section_detail_indent)

    def print_issued_certificates(self, issued_certs: Dict[str, Any], issued_path: str, cert_section_indent: str):
        """Print issued certificates section"""
        for j, (cert_name, cert_data) in enumerate(sorted(issued_certs.items())):
            is_last_cert = (j == len(issued_certs) - 1)
            cert_path = f"{issued_path} -> {cert_name}"
            cert_type = cert_data.get('type', 'unknown')
            
            cert_display = self.format_tree_node(cert_path, f"{cert_name} [{cert_type}]", Colors.BLUE)
            cert_branch = cert_section_indent + ("└──" if is_last_cert else "├──")
            print(f"{cert_branch}{cert_display}")
            
            # Show certificate, private key, and CSR as sub-elements
            cert_details_indent = cert_section_indent + ("    " if is_last_cert else "│   ")
            self.process_sub_items(cert_data, cert_path, cert_details_indent)

    
    def print_certificate_details(self, cert_info: Dict[str, Any], base_path: str, indent: str) -> None:
        """Print certificate details as tree sub-elements"""
        if not cert_info or 'error' in cert_info:
            error_msg = cert_info.get('error', 'Unknown error') if cert_info else 'No certificate data'
            print(f"{indent}├── [!] ERROR: {error_msg}")
            return
        
        details = []
        
        # Handle Subject and Issuer separately - they will be shown as structured tree sections
        # For self-signed certs, we'll show that as a regular detail
        subject = cert_info.get('subject', {})
        issuer = cert_info.get('issuer', {})
        is_self_signed = cert_info.get('is_self_signed', False)
        
        if is_self_signed:
            details.append(('Type', 'Self-signed'))
        
        # Certificate type
        cert_type = cert_info.get('cert_type', '')
        if cert_type:
            details.append(('Cert Type', cert_type.upper().replace('_', ' ')))
        
        # Serial number (full)
        serial = cert_info.get('serial_number', '')
        if serial:
            details.append(('Serial', serial))
        
        # Validity period - separate Valid from and Valid till
        not_before = cert_info.get('not_valid_before', '')
        not_after = cert_info.get('not_valid_after', '')
        if not_before:
            details.append(('Valid from', self.format_datetime(not_before)))
        
        if not_after:
            details.append(('Valid till', self.format_datetime(not_after, with_days_remaining=True)))
        
        # Key information
        key_size = cert_info.get('public_key_size')
        sig_alg = cert_info.get('signature_algorithm', '')
        if key_size or sig_alg:
            key_str = f"{key_size}-bit" if key_size else ""
            if sig_alg:
                key_str += f" {sig_alg}" if key_str else sig_alg
            details.append(('Key', key_str))
        
        # Fingerprint
        fingerprint = cert_info.get('fingerprint_sha256', '')
        if fingerprint:
            if len(fingerprint) > 32:
                fp_display = f"{fingerprint[:16]}...{fingerprint[-16:]}"
            else:
                fp_display = fingerprint
            details.append(('SHA-256', fp_display))
        
        # Certificate modulus (for RSA certificates)
        cert_modulus = cert_info.get('public_modulus', '')
        if cert_modulus:
            modulus_str = str(cert_modulus)
            if len(modulus_str) > 32:
                modulus_display = f"{modulus_str[:16]}...{modulus_str[-16:]}"
            else:
                modulus_display = modulus_str
            details.append(('Modulus', modulus_display))
        
        # Subject Alternative Names will be handled separately as a tree section
        
        # Certificate usage type (server, client, server_client) and key usage info
        key_usage = cert_info.get('key_usage', [])
        ext_key_usage = cert_info.get('extended_key_usage', [])
        basic_constraints = cert_info.get('basic_constraints', {})
        
        # Determine certificate usage type
        if basic_constraints.get('ca'):
            cert_usage_type = "CA"
            path_len = basic_constraints.get('path_length')
            if path_len is not None:
                cert_usage_type += f" (pathlen={path_len})"
        else:
            has_server = 'server_auth' in ext_key_usage
            has_client = 'client_auth' in ext_key_usage
            has_digital_sig = 'digital_signature' in key_usage
            has_key_enc = 'key_encipherment' in key_usage
            
            if has_server and has_client:
                cert_usage_type = "server_client"
            elif has_server or has_key_enc:
                cert_usage_type = "server"
            elif has_client or has_digital_sig:
                cert_usage_type = "client"
            else:
                cert_usage_type = "unknown"
        
        details.append(('Usage Type', cert_usage_type))
        
        # Key Usage
        if key_usage:
            details.append(('Key Usage', ', '.join(key_usage)))
        
        # Extended Key Usage
        if ext_key_usage:
            details.append(('Ext Key Usage', ', '.join(ext_key_usage)))
        
        # Basic Constraints (for CA certificates)
        if basic_constraints.get('ca'):
            bc_str = "CA=true"
            path_len = basic_constraints.get('path_length')
            if path_len is not None:
                bc_str += f", pathlen={path_len}"
            details.append(('Basic Constraints', bc_str))
        
        # Print regular details first (without subject, issuer, SANs)
        for i, (label, value) in enumerate(details):
            is_last_detail = (i == len(details) - 1)
            detail_path = f"{base_path} -> {label.lower().replace(' ', '_').replace('&', 'and')}"
            detail_marker = self.get_change_marker_for_path(detail_path)
            detail_color = self.get_change_color_for_path(detail_path)
            
            # Always use junction (├) for regular details since we'll have subject/issuer/SANs after
            branch = "├──"
            
            detail_display = f"[{detail_marker}] {label}: {value}"
            
            if detail_marker in ['+', '-', '~']:
                detail_display = self.colorize(detail_display, detail_color)
                
            print(f"{indent}{branch} {detail_display}")
        
        # Print structured sections for Subject, Issuer, and SANs
        if isinstance(subject, dict) and subject:
            self.print_x509_name_tree(subject, 'Subject', base_path, indent)
        
        if isinstance(issuer, dict) and issuer and not is_self_signed:
            self.print_x509_name_tree(issuer, 'Issuer', base_path, indent)
        
        sans = cert_info.get('subject_alternative_names', [])
        if sans:
            self.print_sans_tree(sans, base_path, indent)
        
        # Print file information last
        self.print_file_info_tree(cert_info, base_path, indent)
    
    def print_private_key_details(self, key_info: Dict[str, Any], base_path: str, indent: str) -> None:
        """Print private key details as tree sub-elements"""
        if not key_info or 'error' in key_info:
            error_msg = key_info.get('error', 'Unknown error') if key_info else 'No private key data'
            print(f"{indent}├── [!] ERROR: {error_msg}")
            return
        
        details = []
        
        # Key type and size
        key_type = key_info.get('key_type', 'Unknown')
        key_size = key_info.get('size') or key_info.get('key_strength')
        if key_size:
            details.append(('Type & Size', f"{key_size}-bit {key_type}"))
        elif key_type != 'Unknown':
            details.append(('Type', key_type))
        
        # Encryption status
        encrypted = key_info.get('encrypted', False)
        has_passphrase = key_info.get('has_passphrase_file', False)
        if encrypted:
            enc_str = "Encrypted"
            if has_passphrase:
                enc_str += " (passphrase file exists)"
            details.append(('Encryption', enc_str))
        else:
            details.append(('Encryption', "Unencrypted"))
        
        # Public exponent (for RSA keys)
        pub_exp = key_info.get('public_exponent')
        if pub_exp and key_type == 'RSA':
            details.append(('Public Exponent', str(pub_exp)))
        
        # Curve (for EC keys)
        curve = key_info.get('curve')
        if curve:
            details.append(('Curve', curve))
        
        # Modulus (for RSA keys)
        modulus = key_info.get('public_modulus', '')
        if modulus:
            modulus_str = str(modulus)
            if len(modulus_str) > 32:
                modulus_display = f"{modulus_str[:16]}...{modulus_str[-16:]}"
            else:
                modulus_display = modulus_str
            details.append(('Modulus', modulus_display))
        
        # Print all details with file information using correct tree structure
        self.print_details_with_file_info(details, key_info, base_path, indent)
    
    def print_csr_details(self, csr_info: Dict[str, Any], base_path: str, indent: str) -> None:
        """Print CSR details as tree sub-elements"""
        if not csr_info or 'error' in csr_info:
            error_msg = csr_info.get('error', 'Unknown error') if csr_info else 'No CSR data'
            print(f"{indent}├── [!] ERROR: {error_msg}")
            return
        
        details = []
        
        # Handle Subject separately - it will be shown as structured tree section
        subject = csr_info.get('subject', {})
        
        # Public key information
        key_size = csr_info.get('public_key_size')
        sig_alg = csr_info.get('signature_algorithm', '')
        pub_key_type = csr_info.get('public_key_type', '')
        if key_size or sig_alg:
            key_str = f"{key_size}-bit" if key_size else ""
            if pub_key_type:
                key_str += f" {pub_key_type}" if key_str else pub_key_type
            if sig_alg:
                key_str += f" {sig_alg}" if key_str else sig_alg
            details.append(('Key', key_str))
        
        # Subject Alternative Names will be handled separately as a tree section
        
        # Key Usage
        key_usage = csr_info.get('key_usage', [])
        if key_usage:
            details.append(('Key Usage', ', '.join(key_usage)))
        
        # Extended Key Usage
        ext_key_usage = csr_info.get('extended_key_usage', [])
        if ext_key_usage:
            details.append(('Ext Key Usage', ', '.join(ext_key_usage)))
        
        # Print regular details first (without subject and SANs)
        for i, (label, value) in enumerate(details):
            is_last_detail = (i == len(details) - 1)
            detail_path = f"{base_path} -> {label.lower().replace(' ', '_').replace('&', 'and')}"
            detail_marker = self.get_change_marker_for_path(detail_path)
            detail_color = self.get_change_color_for_path(detail_path)
            
            # Always use junction (├) for regular details since we'll have subject/SANs after
            branch = "├──"
            
            detail_display = f"[{detail_marker}] {label}: {value}"
            
            if detail_marker in ['+', '-', '~']:
                detail_display = self.colorize(detail_display, detail_color)
                
            print(f"{indent}{branch} {detail_display}")
        
        # Print structured sections for Subject and SANs
        if isinstance(subject, dict) and subject:
            self.print_x509_name_tree(subject, 'Subject', base_path, indent)
        
        sans = csr_info.get('subject_alternative_names', [])
        if sans:
            self.print_sans_tree(sans, base_path, indent)
        
        # Print file information last
        self.print_file_info_tree(csr_info, base_path, indent)
    
    def print_ca_tree(self, authorities: Dict[str, Any], indent: str = "", is_last: bool = True, ca_path: str = "authorities") -> None:
        """Recursively print the CA tree structure with change highlighting and bracketed markers"""
        
        # At the root level, print the Certificate Authorities header
        if indent == "":
            header_display = self.format_tree_item(":", "Certificate Authorities", len(authorities))
            # Headers always use white-bold color regardless of change status
            header_color = Colors.BOLD + Colors.WHITE
            print(self.colorize(header_display, header_color))
        
        for i, (ca_name, ca_data) in enumerate(sorted(authorities.items())):
            is_last_ca = (i == len(authorities) - 1)
            current_path = f"{ca_path} -> {ca_name}"
            
            # Determine the tree symbols
            branch, next_indent = self.get_tree_branch(indent, is_last_ca)
            
            # Format CA name with bracketed marker
            ca_display = self.format_tree_node(current_path, ca_name, Colors.BOLD + Colors.BLUE)
            print(f"{branch}{ca_display}")
            
            # Print all sections for this CA
            self.print_ca_sections(ca_data, current_path, next_indent)
    
    def print_pki_tree(self, state: Dict[str, Any], title: str) -> None:
        """Print the full PKI tree structure"""
        print(self.colorize(f"PKI Structure - {title}", Colors.BOLD + Colors.CYAN))
        print()

        authorities = state.get('authorities', {})
        if not authorities:
            print("No authorities found")
            return
        
        self.print_ca_tree(authorities)
        print()  # Empty line after tree
    
    def compare_states(self, before_file: str, after_file: str) -> bool:
        """Main method to compare two state files"""
        # Load the JSON files
        before_state = self.load_json_file(before_file)
        after_state = self.load_json_file(after_file)
        
        # Print header
        self.print_header(before_file, after_file)
        
        # Compare the states
        self.compare_values(before_state, after_state, [])
        
        # Print "After" tree with change markers
        self.print_pki_tree(after_state, "AFTER (with changes highlighted)")
        
        
        self.print_summary(after_state)
        
        # Return True if there are differences
        return len(self.differences) > 0


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="Compare two PKI state JSON dumps and show differences",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python scripts/state_compare.py /tmp/pki_state/before.json /tmp/pki_state/after.json
  python scripts/state_compare.py --no-color state1.json state2.json > diff.txt
  python scripts/state_compare.py --color state1.json state2.json  # Force colors even when not TTY
        """
    )
    
    parser.add_argument("before", 
                       help="Path to the 'before' state JSON file")
    parser.add_argument("after", 
                       help="Path to the 'after' state JSON file")
    color_group = parser.add_mutually_exclusive_group()
    color_group.add_argument("--no-color", action="store_true",
                            help="Disable colored output")
    color_group.add_argument("--color", action="store_true",
                            help="Force colored output even when output is not a TTY")
    
    args = parser.parse_args()
    
    # Validate file paths
    if not Path(args.before).exists():
        print(f"Error: Before file '{args.before}' does not exist", file=sys.stderr)
        sys.exit(1)
        
    if not Path(args.after).exists():
        print(f"Error: After file '{args.after}' does not exist", file=sys.stderr)
        sys.exit(1)
    
    # Create comparator and run comparison
    use_colors = args.color or (not args.no_color and sys.stdout.isatty())
    comparator = StateComparator(use_colors=use_colors)
    
    try:
        has_differences = comparator.compare_states(args.before, args.after)
        # Exit with code 1 if there are differences (similar to diff command)
        sys.exit(1 if has_differences else 0)
    except Exception as e:
        print(f"Error: Failed to compare states: {e}", file=sys.stderr)
        sys.exit(2)


if __name__ == "__main__":
    main()