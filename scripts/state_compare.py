#!/usr/bin/env python3
# Copyright 2023 Volodymyr Melnyk
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
PKI State Comparison Script

This script compares two PKI state JSON dumps generated by state_dump.py
and displays the differences in a unified diff-style format with highlighting.
It recursively compares the data structures and shows what changed between
two PKI state snapshots.

Usage:
    python scripts/state_compare.py <before.json> <after.json>
"""

import argparse
import json
import sys
from typing import Dict, Any, List, Tuple, Union
from pathlib import Path


class Colors:
    """ANSI color codes for terminal output"""
    RESET = '\033[0m'
    BOLD = '\033[1m'
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'


class StateComparator:
    """Main class for comparing PKI state dumps"""
    
    def __init__(self, use_colors: bool = True):
        self.use_colors = use_colors
        self.differences = []
        self.change_markers = {}  # path -> change type for tree display
        
    def colorize(self, text: str, color: str) -> str:
        """Apply color to text if colors are enabled"""
        if not self.use_colors:
            return text
        return f"{color}{text}{Colors.RESET}"
    
    def load_json_file(self, file_path: str) -> Dict[str, Any]:
        """Load and parse JSON file"""
        try:
            with open(file_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"Error: File '{file_path}' not found", file=sys.stderr)
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"Error: Invalid JSON in '{file_path}': {e}", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error: Failed to read '{file_path}': {e}", file=sys.stderr)
            sys.exit(1)
    
    def get_path_string(self, path: List[str]) -> str:
        """Convert path list to a readable string"""
        if not path:
            return "root"
        return " -> ".join(path)
    
    def compare_values(self, old_val: Any, new_val: Any, path: List[str]) -> None:
        """Compare two values and record differences"""
        path_str = self.get_path_string(path)
        
        if old_val == new_val:
            return
            
        # Handle different types
        if type(old_val) != type(new_val):
            diff = {
                'type': 'type_change',
                'path': path_str,
                'old_type': type(old_val).__name__,
                'new_type': type(new_val).__name__,
                'old_value': old_val,
                'new_value': new_val
            }
            self.differences.append(diff)
            self.change_markers[path_str] = 'changed'
            return
        
        # Handle dictionaries recursively
        if isinstance(old_val, dict) and isinstance(new_val, dict):
            self.compare_dicts(old_val, new_val, path)
            return
            
        # Handle lists recursively
        if isinstance(old_val, list) and isinstance(new_val, list):
            self.compare_lists(old_val, new_val, path)
            return
        
        # Handle primitive value changes
        diff = {
            'type': 'value_change',
            'path': path_str,
            'old_value': old_val,
            'new_value': new_val
        }
        self.differences.append(diff)
        self.change_markers[path_str] = 'changed'
    
    def compare_dicts(self, old_dict: Dict[str, Any], new_dict: Dict[str, Any], path: List[str]) -> None:
        """Compare two dictionaries recursively"""
        all_keys = set(old_dict.keys()) | set(new_dict.keys())
        
        for key in sorted(all_keys):
            current_path = path + [key]
            current_path_str = self.get_path_string(current_path)
            
            if key not in old_dict:
                # Key was added
                diff = {
                    'type': 'added',
                    'path': current_path_str,
                    'value': new_dict[key]
                }
                self.differences.append(diff)
                self.change_markers[current_path_str] = 'added'
            elif key not in new_dict:
                # Key was removed
                diff = {
                    'type': 'removed',
                    'path': current_path_str,
                    'value': old_dict[key]
                }
                self.differences.append(diff)
                self.change_markers[current_path_str] = 'removed'
            else:
                # Key exists in both, compare values
                self.compare_values(old_dict[key], new_dict[key], current_path)
    
    def compare_lists(self, old_list: List[Any], new_list: List[Any], path: List[str]) -> None:
        """Compare two lists"""
        # For simplicity, we'll compare lists element by element
        # This could be enhanced with more sophisticated diff algorithms
        max_len = max(len(old_list), len(new_list))
        
        for i in range(max_len):
            current_path = path + [f"[{i}]"]
            
            if i >= len(old_list):
                # Element was added
                self.differences.append({
                    'type': 'added',
                    'path': self.get_path_string(current_path),
                    'value': new_list[i]
                })
            elif i >= len(new_list):
                # Element was removed
                self.differences.append({
                    'type': 'removed',
                    'path': self.get_path_string(current_path),
                    'value': old_list[i]
                })
            else:
                # Compare elements
                self.compare_values(old_list[i], new_list[i], current_path)
    
    def format_value(self, value: Any, max_length: int = 100) -> str:
        """Format a value for display, truncating if too long"""
        if isinstance(value, (dict, list)):
            json_str = json.dumps(value, separators=(',', ':'))
            if len(json_str) > max_length:
                return json_str[:max_length] + "..."
            return json_str
        else:
            str_val = str(value)
            if len(str_val) > max_length:
                return str_val[:max_length] + "..."
            return str_val
    
    def print_header(self, before_file: str, after_file: str) -> None:
        """Print comparison header"""
        print("PKI State Comparison")
        print(self.colorize(f"Before: {before_file}", Colors.YELLOW + Colors.BOLD))
        print(self.colorize(f"After:  {after_file}", Colors.WHITE + Colors.BOLD))
        print()
    
    def print_differences(self) -> None:
        """Print all differences in unified diff style"""
        if not self.differences:
            print(self.colorize("No differences found", Colors.GREEN))
            return
        
        print(self.colorize(f"Found {len(self.differences)} differences:", Colors.BOLD))
        print()
        
        # Group differences by path for better organization
        by_path = {}
        for diff in self.differences:
            path_parts = diff['path'].split(' -> ')
            if len(path_parts) > 1:
                base_path = ' -> '.join(path_parts[:-1])
            else:
                base_path = 'root'
            
            if base_path not in by_path:
                by_path[base_path] = []
            by_path[base_path].append(diff)
        
        # Print differences grouped by path
        for base_path in sorted(by_path.keys()):
            path_diffs = by_path[base_path]
            
            # Print path header
            print(self.colorize(f"@@ {base_path} @@", Colors.MAGENTA))
            
            for diff in path_diffs:
                self.print_single_difference(diff)
            
            print()  # Empty line between sections
    
    def print_single_difference(self, diff: Dict[str, Any]) -> None:
        """Print a single difference"""
        diff_type = diff['type']
        path = diff['path']
        
        if diff_type == 'added':
            print(self.colorize(f"+ {path}: {self.format_value(diff['value'])}", Colors.GREEN))
            
        elif diff_type == 'removed':
            print(self.colorize(f"- {path}: {self.format_value(diff['value'])}", Colors.RED))
            
        elif diff_type == 'value_change':
            print(self.colorize(f"- {path}: {self.format_value(diff['old_value'])}", Colors.RED))
            print(self.colorize(f"+ {path}: {self.format_value(diff['new_value'])}", Colors.GREEN))
            
        elif diff_type == 'type_change':
            old_type = diff['old_type']
            new_type = diff['new_type']
            print(self.colorize(f"~ {path}: type changed from {old_type} to {new_type}", Colors.YELLOW))
            print(self.colorize(f"- {path}: {self.format_value(diff['old_value'])}", Colors.RED))
            print(self.colorize(f"+ {path}: {self.format_value(diff['new_value'])}", Colors.GREEN))
    
    def print_summary(self) -> None:
        """Print a summary of changes"""
        if not self.differences:
            return
            
        # Count different types of changes
        counts = {}
        for diff in self.differences:
            diff_type = diff['type']
            counts[diff_type] = counts.get(diff_type, 0) + 1
        
        print(self.colorize("Summary:", Colors.BOLD + Colors.BLUE))
        
        for diff_type, count in sorted(counts.items()):
            type_name = diff_type.replace('_', ' ').title()
            color = Colors.GREEN if diff_type == 'added' else Colors.RED if diff_type == 'removed' else Colors.YELLOW
            print(self.colorize(f"  {type_name}: {count}", color))
        
        print(self.colorize(f"  Total changes: {len(self.differences)}", Colors.BOLD))
    
    def get_change_marker_for_path(self, path: str) -> str:
        """Get the change marker symbol for a given path"""
        # First check if this exact path has a change
        change_type = self.change_markers.get(path, 'unchanged')
        if change_type != 'unchanged':
            if change_type == 'added':
                return '+'
            elif change_type == 'removed':
                return '-'
            elif change_type == 'changed':
                return '~'
        
        # If no direct change, check if any parent path was added or removed
        # This ensures child elements are marked when their parent is added/removed
        path_parts = path.split(' -> ')
        for i in range(1, len(path_parts)):
            parent_path = ' -> '.join(path_parts[:i])
            parent_change = self.change_markers.get(parent_path, 'unchanged')
            if parent_change == 'added':
                return '+'
            elif parent_change == 'removed':
                return '-'
        
        # Return equals sign for unchanged items
        return '='
    
    def get_change_color_for_path(self, path: str) -> str:
        """Get the color for a given path based on its change status"""
        # First check if this exact path has a change
        change_type = self.change_markers.get(path, 'unchanged')
        if change_type != 'unchanged':
            if change_type == 'added':
                return Colors.GREEN
            elif change_type == 'removed':
                return Colors.RED
            elif change_type == 'changed':
                return Colors.YELLOW
        
        # If no direct change, check if any parent path was added or removed
        path_parts = path.split(' -> ')
        for i in range(1, len(path_parts)):
            parent_path = ' -> '.join(path_parts[:i])
            parent_change = self.change_markers.get(parent_path, 'unchanged')
            if parent_change == 'added':
                return Colors.GREEN
            elif parent_change == 'removed':
                return Colors.RED
        
        return Colors.RESET
    
    def format_certificate_info(self, cert_info: Dict[str, Any]) -> str:
        """Format certificate information for display"""
        if not cert_info or 'error' in cert_info:
            return f"[ERROR: {cert_info.get('error', 'Unknown error')}]"
        
        subject = cert_info.get('subject', 'Unknown Subject')
        # Extract CN from the subject string
        if 'CN=' in subject:
            cn_start = subject.find('CN=') + 3
            cn_end = subject.find(',', cn_start)
            if cn_end == -1:
                cn_end = subject.find('>', cn_start)
            cn = subject[cn_start:cn_end] if cn_end > cn_start else subject[cn_start:]
        else:
            cn = 'No CN'
        
        serial = cert_info.get('serial_number', 'Unknown Serial')
        not_after = cert_info.get('not_valid_after', '')
        if not_after:
            # Simplify the date format
            try:
                from datetime import datetime
                dt = datetime.fromisoformat(not_after.replace('Z', '+00:00'))
                not_after = dt.strftime('%Y-%m-%d')
            except:
                pass
        
        return f"{cn} (Serial: {serial[:8]}{'...' if len(serial) > 8 else ''}, Expires: {not_after})"
    
    def print_ca_tree(self, authorities: Dict[str, Any], indent: str = "", is_last: bool = True, ca_path: str = "authorities") -> None:
        """Recursively print the CA tree structure with change highlighting and bracketed markers"""
        
        # At the root level, print the Certificate Authorities header
        if indent == "":
            authorities_path = ca_path
            authorities_marker = self.get_change_marker_for_path(authorities_path)
            if authorities_marker in ['+', '-', '~']:
                header_color = self.get_change_color_for_path(authorities_path)
            else:
                header_color = Colors.BOLD + Colors.WHITE
            header_display = f"[:] Certificate Authorities ({len(authorities)})"
            print(self.colorize(header_display, header_color))
        
        for i, (ca_name, ca_data) in enumerate(sorted(authorities.items())):
            is_last_ca = (i == len(authorities) - 1)
            current_path = f"{ca_path} -> {ca_name}"
            
            # Determine the tree symbols
            if indent == "":
                # Root level - but now we have the header, so we're under it
                branch = " ├──" if not is_last_ca else " └──"
                next_indent = " │   " if not is_last_ca else "     "
            else:
                branch = indent + ("├──" if not is_last_ca else "└──")
                next_indent = indent + ("│   " if not is_last_ca else "    ")
            
            # Get change marker and color for this CA
            change_marker = self.get_change_marker_for_path(current_path)
            change_color = self.get_change_color_for_path(current_path)
            
            # Format CA name with bracketed marker
            ca_display = f"[{change_marker}] {ca_name}"
            if change_marker in ['+', '-', '~']:
                ca_display = self.colorize(ca_display, change_color)
            else:
                ca_display = self.colorize(ca_display, Colors.BOLD + Colors.BLUE)
            
            print(f"{branch}{ca_display}")
            
            # Determine what sections exist
            own_cert = ca_data.get('own_certificate')
            issued_certs = ca_data.get('issued_certificates', {})
            child_authorities = ca_data.get('authorities', {})
            
            # Count the sections that will be displayed
            sections = []
            if own_cert:
                sections.append('certificate')
            if child_authorities:
                sections.append('authorities')
            if issued_certs:
                sections.append('issued_certificates')
            
            section_count = 0
            
            # Show CA's own certificate info
            if own_cert:
                section_count += 1
                is_last_section = (section_count == len(sections))
                
                cert_path = f"{current_path} -> own_certificate"
                cert_marker = self.get_change_marker_for_path(cert_path)
                cert_color = self.get_change_color_for_path(cert_path)
                cert_info = self.format_certificate_info(own_cert)
                cert_display = f"[{cert_marker}] Certificate: {cert_info}"
                if cert_marker in ['+', '-', '~']:
                    cert_display = self.colorize(cert_display, cert_color)
                
                section_branch = next_indent + ("└──" if is_last_section else "├──")
                print(f"{section_branch}{cert_display}")
            
            # Show child authorities section
            if child_authorities:
                section_count += 1
                is_last_section = (section_count == len(sections))
                
                # Show Certificate Authorities header for child CAs
                authorities_path = f"{current_path} -> authorities"
                authorities_marker = self.get_change_marker_for_path(authorities_path)
                if authorities_marker in ['+', '-', '~']:
                    authorities_color = self.get_change_color_for_path(authorities_path)
                else:
                    authorities_color = Colors.BOLD + Colors.WHITE
                authorities_display = f"[:] Certificate Authorities ({len(child_authorities)})"
                
                section_branch = next_indent + ("└──" if is_last_section else "├──")
                print(f"{section_branch}{self.colorize(authorities_display, authorities_color)}")
                
                # Show each child CA
                child_indent = next_indent + ("    " if is_last_section else "│   ")
                for j, (child_name, child_data) in enumerate(sorted(child_authorities.items())):
                    is_last_child = (j == len(child_authorities) - 1)
                    child_path = f"{current_path} -> authorities -> {child_name}"
                    child_marker = self.get_change_marker_for_path(child_path)
                    child_color = self.get_change_color_for_path(child_path)
                    
                    child_branch = child_indent + ("└──" if is_last_child else "├──")
                    child_display = f"[{child_marker}] {child_name}"
                    if child_marker in ['+', '-', '~']:
                        child_display = self.colorize(child_display, child_color)
                    else:
                        child_display = self.colorize(child_display, Colors.BOLD + Colors.BLUE)
                    
                    print(f"{child_branch}{child_display}")
                    
                    # Show child's sections
                    child_next_indent = child_indent + ("    " if is_last_child else "│   ")
                    child_own_cert = child_data.get('own_certificate')
                    child_issued_certs = child_data.get('issued_certificates', {})
                    child_child_authorities = child_data.get('authorities', {})
                    
                    child_sections = []
                    if child_own_cert:
                        child_sections.append('certificate')
                    if child_child_authorities:
                        child_sections.append('authorities')
                    if child_issued_certs:
                        child_sections.append('issued_certificates')
                    
                    child_section_count = 0
                    
                    # Child's certificate
                    if child_own_cert:
                        child_section_count += 1
                        is_last_child_section = (child_section_count == len(child_sections))
                        
                        cert_path = f"{child_path} -> own_certificate"
                        cert_marker = self.get_change_marker_for_path(cert_path)
                        cert_color = self.get_change_color_for_path(cert_path)
                        cert_info = self.format_certificate_info(child_own_cert)
                        cert_display = f"[{cert_marker}] Certificate: {cert_info}"
                        if cert_marker in ['+', '-', '~']:
                            cert_display = self.colorize(cert_display, cert_color)
                        
                        child_cert_branch = child_next_indent + ("└──" if is_last_child_section else "├──")
                        print(f"{child_cert_branch}{cert_display}")
                    
                    # Recursively handle nested authorities
                    if child_child_authorities:
                        child_section_count += 1
                        is_last_child_section = (child_section_count == len(child_sections))
                        nested_indent = child_next_indent + ("    " if is_last_child_section else "│   ")
                        self.print_ca_tree(child_child_authorities, nested_indent, True, f"{child_path} -> authorities")
                    
                    # Child's issued certificates
                    if child_issued_certs:
                        child_section_count += 1
                        is_last_child_section = (child_section_count == len(child_sections))
                        
                        issued_path = f"{child_path} -> issued_certificates"
                        issued_marker = self.get_change_marker_for_path(issued_path)
                        if issued_marker in ['+', '-', '~']:
                            issued_color = self.get_change_color_for_path(issued_path)
                        else:
                            issued_color = Colors.BOLD + Colors.WHITE
                        issued_display = f"[:] Issued Certificates ({len(child_issued_certs)})"
                        
                        child_issued_branch = child_next_indent + ("└──" if is_last_child_section else "├──")
                        print(f"{child_issued_branch}{self.colorize(issued_display, issued_color)}")
                        
                        # Show each issued certificate
                        cert_section_indent = child_next_indent + ("    " if is_last_child_section else "│   ")
                        
                        for k, (cert_name, cert_data) in enumerate(sorted(child_issued_certs.items())):
                            is_last_cert = (k == len(child_issued_certs) - 1)
                            cert_path = f"{issued_path} -> {cert_name}"
                            cert_marker = self.get_change_marker_for_path(cert_path)
                            cert_color = self.get_change_color_for_path(cert_path)
                            
                            cert_branch = cert_section_indent + ("└──" if is_last_cert else "├──")
                            
                            cert_info = cert_data.get('certificate')
                            cert_type = cert_data.get('type', 'unknown')
                            if cert_info:
                                cert_details = self.format_certificate_info(cert_info)
                                cert_display = f"[{cert_marker}] {cert_name} [{cert_type}]: {cert_details}"
                            else:
                                cert_display = f"[{cert_marker}] {cert_name} [{cert_type}]: [No certificate info]"
                            
                            if cert_marker in ['+', '-', '~']:
                                cert_display = self.colorize(cert_display, cert_color)
                            
                            print(f"{cert_branch}{cert_display}")
            
            # Show issued certificates section
            if issued_certs:
                section_count += 1
                is_last_section = (section_count == len(sections))
                
                issued_path = f"{current_path} -> issued_certificates"
                issued_marker = self.get_change_marker_for_path(issued_path)
                if issued_marker in ['+', '-', '~']:
                    issued_color = self.get_change_color_for_path(issued_path)
                else:
                    issued_color = Colors.BOLD + Colors.WHITE
                issued_display = f"[:] Issued Certificates ({len(issued_certs)})"
                
                section_branch = next_indent + ("└──" if is_last_section else "├──")
                print(f"{section_branch}{self.colorize(issued_display, issued_color)}")
                
                # Determine the indent for certificates under this section
                cert_section_indent = next_indent + ("    " if is_last_section else "│   ")
                
                # List each issued certificate
                for j, (cert_name, cert_data) in enumerate(sorted(issued_certs.items())):
                    is_last_cert = (j == len(issued_certs) - 1)
                    cert_path = f"{issued_path} -> {cert_name}"
                    cert_marker = self.get_change_marker_for_path(cert_path)
                    cert_color = self.get_change_color_for_path(cert_path)
                    
                    cert_branch = cert_section_indent + ("└──" if is_last_cert else "├──")
                    
                    # Format certificate information
                    cert_info = cert_data.get('certificate')
                    cert_type = cert_data.get('type', 'unknown')
                    if cert_info:
                        cert_details = self.format_certificate_info(cert_info)
                        cert_display = f"[{cert_marker}] {cert_name} [{cert_type}]: {cert_details}"
                    else:
                        cert_display = f"[{cert_marker}] {cert_name} [{cert_type}]: [No certificate info]"
                    
                    if cert_marker in ['+', '-', '~']:
                        cert_display = self.colorize(cert_display, cert_color)
                    
                    print(f"{cert_branch}{cert_display}")
    
    def print_pki_tree(self, state: Dict[str, Any], title: str) -> None:
        """Print the full PKI tree structure"""
        print(self.colorize(f"PKI Structure - {title}", Colors.BOLD + Colors.CYAN))
        print()

        authorities = state.get('authorities', {})
        if not authorities:
            print("No authorities found")
            return
        
        self.print_ca_tree(authorities)
        print()  # Empty line after tree
    
    def compare_states(self, before_file: str, after_file: str) -> bool:
        """Main method to compare two state files"""
        # Load the JSON files
        before_state = self.load_json_file(before_file)
        after_state = self.load_json_file(after_file)
        
        # Print header
        self.print_header(before_file, after_file)
        
        # Compare the states
        self.compare_values(before_state, after_state, [])
        
        # Print "After" tree with change markers
        self.print_pki_tree(after_state, "AFTER (with changes highlighted)")
        
        # Print traditional diff output
        if self.differences:
            self.print_differences()
        
        self.print_summary()
        
        # Return True if there are differences
        return len(self.differences) > 0


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="Compare two PKI state JSON dumps and show differences",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python scripts/state_compare.py /tmp/pki_state/before.json /tmp/pki_state/after.json
  python scripts/state_compare.py --no-color state1.json state2.json > diff.txt
        """
    )
    
    parser.add_argument("before", 
                       help="Path to the 'before' state JSON file")
    parser.add_argument("after", 
                       help="Path to the 'after' state JSON file")
    parser.add_argument("--no-color", action="store_true",
                       help="Disable colored output")
    
    args = parser.parse_args()
    
    # Validate file paths
    if not Path(args.before).exists():
        print(f"Error: Before file '{args.before}' does not exist", file=sys.stderr)
        sys.exit(1)
        
    if not Path(args.after).exists():
        print(f"Error: After file '{args.after}' does not exist", file=sys.stderr)
        sys.exit(1)
    
    # Create comparator and run comparison
    use_colors = not args.no_color and sys.stdout.isatty()
    comparator = StateComparator(use_colors=use_colors)
    
    try:
        has_differences = comparator.compare_states(args.before, args.after)
        # Exit with code 1 if there are differences (similar to diff command)
        sys.exit(1 if has_differences else 0)
    except Exception as e:
        print(f"Error: Failed to compare states: {e}", file=sys.stderr)
        sys.exit(2)


if __name__ == "__main__":
    main()