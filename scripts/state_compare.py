#!/usr/bin/env python3
# Copyright 2023 Volodymyr Melnyk
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
PKI State Comparison Script

This script compares two PKI state JSON dumps generated by state_dump.py
and displays the differences in a unified diff-style format with highlighting.
It recursively compares the data structures and shows what changed between
two PKI state snapshots.

Usage:
    python scripts/state_compare.py <before.json> <after.json>
"""

import argparse
import json
import sys
from typing import Dict, Any, List, Tuple, Union
from pathlib import Path


class Colors:
    """ANSI color codes for terminal output"""
    RESET = '\033[0m'
    BOLD = '\033[1m'
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'


class StateComparator:
    """Main class for comparing PKI state dumps"""
    
    def __init__(self, use_colors: bool = True):
        self.use_colors = use_colors
        self.differences = []
        self.change_markers = {}  # path -> change type for tree display
        
    def colorize(self, text: str, color: str) -> str:
        """Apply color to text if colors are enabled"""
        if not self.use_colors:
            return text
        return f"{color}{text}{Colors.RESET}"
    
    def load_json_file(self, file_path: str) -> Dict[str, Any]:
        """Load and parse JSON file"""
        try:
            with open(file_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"Error: File '{file_path}' not found", file=sys.stderr)
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"Error: Invalid JSON in '{file_path}': {e}", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error: Failed to read '{file_path}': {e}", file=sys.stderr)
            sys.exit(1)
    
    def get_path_string(self, path: List[str]) -> str:
        """Convert path list to a readable string"""
        if not path:
            return "root"
        return " -> ".join(path)
    
    def compare_values(self, old_val: Any, new_val: Any, path: List[str]) -> None:
        """Compare two values and record differences"""
        path_str = self.get_path_string(path)
        
        if old_val == new_val:
            return
            
        # Handle different types
        if type(old_val) != type(new_val):
            diff = {
                'type': 'type_change',
                'path': path_str,
                'old_type': type(old_val).__name__,
                'new_type': type(new_val).__name__,
                'old_value': old_val,
                'new_value': new_val
            }
            self.differences.append(diff)
            self.change_markers[path_str] = 'changed'
            return
        
        # Handle dictionaries recursively
        if isinstance(old_val, dict) and isinstance(new_val, dict):
            self.compare_dicts(old_val, new_val, path)
            return
            
        # Handle lists recursively
        if isinstance(old_val, list) and isinstance(new_val, list):
            self.compare_lists(old_val, new_val, path)
            return
        
        # Handle primitive value changes
        diff = {
            'type': 'value_change',
            'path': path_str,
            'old_value': old_val,
            'new_value': new_val
        }
        self.differences.append(diff)
        self.change_markers[path_str] = 'changed'
    
    def compare_dicts(self, old_dict: Dict[str, Any], new_dict: Dict[str, Any], path: List[str]) -> None:
        """Compare two dictionaries recursively"""
        all_keys = set(old_dict.keys()) | set(new_dict.keys())
        
        for key in sorted(all_keys):
            current_path = path + [key]
            current_path_str = self.get_path_string(current_path)
            
            if key not in old_dict:
                # Key was added
                diff = {
                    'type': 'added',
                    'path': current_path_str,
                    'value': new_dict[key]
                }
                self.differences.append(diff)
                self.change_markers[current_path_str] = 'added'
            elif key not in new_dict:
                # Key was removed
                diff = {
                    'type': 'removed',
                    'path': current_path_str,
                    'value': old_dict[key]
                }
                self.differences.append(diff)
                self.change_markers[current_path_str] = 'removed'
            else:
                # Key exists in both, compare values
                self.compare_values(old_dict[key], new_dict[key], current_path)
    
    def compare_lists(self, old_list: List[Any], new_list: List[Any], path: List[str]) -> None:
        """Compare two lists"""
        # For simplicity, we'll compare lists element by element
        # This could be enhanced with more sophisticated diff algorithms
        max_len = max(len(old_list), len(new_list))
        
        for i in range(max_len):
            current_path = path + [f"[{i}]"]
            
            if i >= len(old_list):
                # Element was added
                self.differences.append({
                    'type': 'added',
                    'path': self.get_path_string(current_path),
                    'value': new_list[i]
                })
            elif i >= len(new_list):
                # Element was removed
                self.differences.append({
                    'type': 'removed',
                    'path': self.get_path_string(current_path),
                    'value': old_list[i]
                })
            else:
                # Compare elements
                self.compare_values(old_list[i], new_list[i], current_path)
    
    def format_value(self, value: Any, max_length: int = 100) -> str:
        """Format a value for display, truncating if too long"""
        if isinstance(value, (dict, list)):
            json_str = json.dumps(value, separators=(',', ':'))
            if len(json_str) > max_length:
                return json_str[:max_length] + "..."
            return json_str
        else:
            str_val = str(value)
            if len(str_val) > max_length:
                return str_val[:max_length] + "..."
            return str_val
    
    def print_header(self, before_file: str, after_file: str) -> None:
        """Print comparison header"""
        print("PKI State Comparison")
        print(self.colorize(f"Before: {before_file}", Colors.YELLOW + Colors.BOLD))
        print(self.colorize(f"After:  {after_file}", Colors.WHITE + Colors.BOLD))
        print()
    
    def print_differences(self) -> None:
        """Print all differences in unified diff style"""
        if not self.differences:
            print(self.colorize("No differences found", Colors.GREEN))
            return
        
        print(self.colorize(f"Found {len(self.differences)} differences:", Colors.BOLD))
        print()
        
        # Group differences by path for better organization
        by_path = {}
        for diff in self.differences:
            path_parts = diff['path'].split(' -> ')
            if len(path_parts) > 1:
                base_path = ' -> '.join(path_parts[:-1])
            else:
                base_path = 'root'
            
            if base_path not in by_path:
                by_path[base_path] = []
            by_path[base_path].append(diff)
        
        # Print differences grouped by path
        for base_path in sorted(by_path.keys()):
            path_diffs = by_path[base_path]
            
            # Print path header
            print(self.colorize(f"@@ {base_path} @@", Colors.MAGENTA))
            
            for diff in path_diffs:
                self.print_single_difference(diff)
            
            print()  # Empty line between sections
    
    def print_single_difference(self, diff: Dict[str, Any]) -> None:
        """Print a single difference with detailed formatting for PKI objects"""
        diff_type = diff['type']
        path = diff['path']
        
        if diff_type == 'added':
            formatted_value = self.format_pki_value_for_display(diff['value'], path)
            print(self.colorize(f"+ {path}: {formatted_value}", Colors.GREEN))
            
        elif diff_type == 'removed':
            formatted_value = self.format_pki_value_for_display(diff['value'], path)
            print(self.colorize(f"- {path}: {formatted_value}", Colors.RED))
            
        elif diff_type == 'value_change':
            old_formatted = self.format_pki_value_for_display(diff['old_value'], path)
            new_formatted = self.format_pki_value_for_display(diff['new_value'], path)
            print(self.colorize(f"- {path}: {old_formatted}", Colors.RED))
            print(self.colorize(f"+ {path}: {new_formatted}", Colors.GREEN))
            
        elif diff_type == 'type_change':
            old_type = diff['old_type']
            new_type = diff['new_type']
            print(self.colorize(f"~ {path}: type changed from {old_type} to {new_type}", Colors.YELLOW))
            old_formatted = self.format_pki_value_for_display(diff['old_value'], path)
            new_formatted = self.format_pki_value_for_display(diff['new_value'], path)
            print(self.colorize(f"- {path}: {old_formatted}", Colors.RED))
            print(self.colorize(f"+ {path}: {new_formatted}", Colors.GREEN))
    
    def print_summary(self) -> None:
        """Print a summary of changes"""
        if not self.differences:
            return
            
        # Count different types of changes
        counts = {}
        for diff in self.differences:
            diff_type = diff['type']
            counts[diff_type] = counts.get(diff_type, 0) + 1
        
        print(self.colorize("Summary:", Colors.BOLD + Colors.BLUE))
        
        for diff_type, count in sorted(counts.items()):
            type_name = diff_type.replace('_', ' ').title()
            color = Colors.GREEN if diff_type == 'added' else Colors.RED if diff_type == 'removed' else Colors.YELLOW
            print(self.colorize(f"  {type_name}: {count}", color))
        
        print(self.colorize(f"  Total changes: {len(self.differences)}", Colors.BOLD))
    
    def get_change_marker_for_path(self, path: str) -> str:
        """Get the change marker symbol for a given path"""
        # First check if this exact path has a change
        change_type = self.change_markers.get(path, 'unchanged')
        if change_type != 'unchanged':
            if change_type == 'added':
                return '+'
            elif change_type == 'removed':
                return '-'
            elif change_type == 'changed':
                return '~'
        
        # If no direct change, check if any parent path was added or removed
        # This ensures child elements are marked when their parent is added/removed
        path_parts = path.split(' -> ')
        for i in range(1, len(path_parts)):
            parent_path = ' -> '.join(path_parts[:i])
            parent_change = self.change_markers.get(parent_path, 'unchanged')
            if parent_change == 'added':
                return '+'
            elif parent_change == 'removed':
                return '-'
        
        # Return equals sign for unchanged items
        return '='
    
    def get_change_color_for_path(self, path: str) -> str:
        """Get the color for a given path based on its change status"""
        # First check if this exact path has a change
        change_type = self.change_markers.get(path, 'unchanged')
        if change_type != 'unchanged':
            if change_type == 'added':
                return Colors.GREEN
            elif change_type == 'removed':
                return Colors.RED
            elif change_type == 'changed':
                return Colors.YELLOW
        
        # If no direct change, check if any parent path was added or removed
        path_parts = path.split(' -> ')
        for i in range(1, len(path_parts)):
            parent_path = ' -> '.join(path_parts[:i])
            parent_change = self.change_markers.get(parent_path, 'unchanged')
            if parent_change == 'added':
                return Colors.GREEN
            elif parent_change == 'removed':
                return Colors.RED
        
        return Colors.RESET
    
    def format_certificate_info(self, cert_info: Dict[str, Any]) -> str:
        """Format certificate information for display"""
        if not cert_info or 'error' in cert_info:
            return f"[ERROR: {cert_info.get('error', 'Unknown error')}]"
        
        subject = cert_info.get('subject', 'Unknown Subject')
        # Extract CN from the subject string
        if 'CN=' in subject:
            cn_start = subject.find('CN=') + 3
            cn_end = subject.find(',', cn_start)
            if cn_end == -1:
                cn_end = subject.find('>', cn_start)
            cn = subject[cn_start:cn_end] if cn_end > cn_start else subject[cn_start:]
        else:
            cn = 'No CN'
        
        serial = cert_info.get('serial_number', 'Unknown Serial')
        not_after = cert_info.get('not_valid_after', '')
        validity_status = ""
        if not_after:
            # Simplify the date format and check validity
            try:
                from datetime import datetime, timezone
                dt = datetime.fromisoformat(not_after.replace('Z', '+00:00'))
                not_after_str = dt.strftime('%Y-%m-%d')
                
                # Check if certificate is expiring soon or expired
                now = datetime.now(timezone.utc)
                days_until_expiry = (dt - now).days
                
                if days_until_expiry < 0:
                    validity_status = " [EXPIRED]"
                elif days_until_expiry <= 30:
                    validity_status = f" [EXPIRES IN {days_until_expiry} DAYS]"
                    
                not_after = not_after_str
            except:
                pass
        
        # Add certificate type information
        cert_type_info = ""
        cert_type = cert_info.get('cert_type', '')
        is_self_signed = cert_info.get('is_self_signed', False)
        if cert_type:
            if is_self_signed:
                cert_type_info = f", {cert_type.upper()} [SELF-SIGNED]"
            else:
                cert_type_info = f", {cert_type.upper()}"
        
        # Add key information
        key_info = ""
        key_size = cert_info.get('public_key_size')
        sig_alg = cert_info.get('signature_algorithm', '')
        if key_size:
            key_info = f", {key_size}-bit"
        if sig_alg:
            key_info += f" {sig_alg}"
        
        # Add subject alternative names if available
        san_info = ""
        sans = cert_info.get('subject_alternative_names', [])
        if sans:
            san_count = len(sans)
            if san_count <= 3:
                san_info = f", SANs: {', '.join(sans)}"
            else:
                san_info = f", SANs: {', '.join(sans[:3])} (+{san_count-3} more)"
        
        # Add key usage information
        usage_info = ""
        key_usage = cert_info.get('key_usage', [])
        ext_key_usage = cert_info.get('extended_key_usage', [])
        
        usage_parts = []
        if key_usage:
            usage_parts.append(f"KeyUsage: {', '.join(key_usage)}")
        if ext_key_usage:
            usage_parts.append(f"ExtKeyUsage: {', '.join(ext_key_usage)}")
        if usage_parts:
            usage_info = f", {'; '.join(usage_parts)}"
        
        return f"{cn} (Serial: {serial[:8]}{'...' if len(serial) > 8 else ''}, Expires: {not_after}{validity_status}{cert_type_info}{key_info}{san_info}{usage_info})"
    
    def format_pki_value_for_display(self, value: Any, path: str, max_length: int = 200) -> str:
        """Format PKI-specific values with detailed information"""
        # Check if this is a certificate, private key, or CSR based on the path and value
        if isinstance(value, dict):
            if 'subject' in value and 'issuer' in value and 'serial_number' in value:
                # This is a certificate
                return self.format_detailed_certificate_info(value)
            elif 'size' in value and 'public_exponent' in value and 'encrypted' in value:
                # This is a private key
                return self.format_detailed_private_key_info(value)
            elif 'subject' in value and 'signature_algorithm' in value and 'public_key_size' in value and 'issuer' not in value:
                # This is a CSR
                return self.format_detailed_csr_info(value)
            else:
                # Regular dictionary formatting
                json_str = json.dumps(value, separators=(',', ':'))
                if len(json_str) > max_length:
                    return json_str[:max_length] + "..."
                return json_str
        else:
            return self.format_value(value, max_length)
    
    def format_detailed_certificate_info(self, cert_info: Dict[str, Any]) -> str:
        """Format detailed certificate information for diff display"""
        if 'error' in cert_info:
            return f"[ERROR: {cert_info.get('error', 'Unknown error')}]"
        
        parts = []
        
        # Subject and issuer
        subject = cert_info.get('subject', 'Unknown Subject')
        issuer = cert_info.get('issuer', 'Unknown Issuer')
        parts.append(f"Subject: {subject}")
        if subject != issuer:
            parts.append(f"Issuer: {issuer}")
        else:
            parts.append("[Self-signed]")
        
        # Serial and validity
        serial = cert_info.get('serial_number', 'Unknown')
        parts.append(f"Serial: {serial}")
        
        not_before = cert_info.get('not_valid_before', '')
        not_after = cert_info.get('not_valid_after', '')
        if not_before and not_after:
            try:
                from datetime import datetime, timezone
                before_dt = datetime.fromisoformat(not_before.replace('Z', '+00:00'))
                after_dt = datetime.fromisoformat(not_after.replace('Z', '+00:00'))
                validity = f"{before_dt.strftime('%Y-%m-%d')} to {after_dt.strftime('%Y-%m-%d')}"
                
                # Check validity status
                now = datetime.now(timezone.utc)
                if now > after_dt:
                    validity += " [EXPIRED]"
                elif (after_dt - now).days <= 30:
                    validity += f" [EXPIRES IN {(after_dt - now).days} DAYS]"
                    
                parts.append(f"Validity: {validity}")
            except:
                if not_after:
                    parts.append(f"Expires: {not_after}")
        
        # Key information
        key_size = cert_info.get('public_key_size')
        sig_alg = cert_info.get('signature_algorithm', '')
        if key_size and sig_alg:
            parts.append(f"Key: {key_size}-bit {sig_alg}")
        
        # Fingerprint
        fingerprint = cert_info.get('fingerprint_sha256', '')
        if fingerprint:
            parts.append(f"SHA256: {fingerprint[:16]}...")
        
        return "; ".join(parts)
    
    def format_detailed_private_key_info(self, key_info: Dict[str, Any]) -> str:
        """Format detailed private key information for diff display"""
        if 'error' in key_info:
            return f"[ERROR: {key_info.get('error', 'Unknown error')}]"
        
        parts = []
        
        # Key size and type
        size = key_info.get('size')
        if size:
            parts.append(f"{size}-bit RSA")
        
        # Encryption status
        encrypted = key_info.get('encrypted', False)
        if encrypted:
            parts.append("[ENCRYPTED]")
        else:
            parts.append("[UNENCRYPTED]")
        
        # Public exponent
        pub_exp = key_info.get('public_exponent')
        if pub_exp:
            parts.append(f"PublicExp: {pub_exp}")
        
        # File location
        file_path = key_info.get('file', '')
        if file_path:
            import os
            parts.append(f"File: {os.path.basename(file_path)}")
        
        # Modulus (truncated)
        modulus = key_info.get('public_modulus', '')
        if modulus:
            modulus_str = str(modulus)
            if len(modulus_str) > 32:
                parts.append(f"Modulus: {modulus_str[:16]}...{modulus_str[-16:]}")
            else:
                parts.append(f"Modulus: {modulus_str}")
        
        return "; ".join(parts)
    
    def format_file_size(self, file_size: int) -> str:
        """Format file size in a human-readable way"""
        if file_size >= 1024:
            size_kb = file_size / 1024
            if size_kb >= 1024:
                size_mb = size_kb / 1024
                return f"{size_mb:.2f} MB ({file_size:,} bytes)"
            else:
                return f"{size_kb:.2f} KB ({file_size:,} bytes)"
        else:
            return f"{file_size} bytes"

    def format_datetime(self, datetime_str: str, with_days_remaining: bool = False) -> str:
        """Format datetime string consistently"""
        try:
            from datetime import datetime, timezone
            # Parse the datetime string
            if datetime_str.endswith('Z'):
                dt = datetime.fromisoformat(datetime_str.replace('Z', '+00:00'))
            elif '+' in datetime_str or datetime_str.endswith('UTC'):
                dt = datetime.fromisoformat(datetime_str.replace('Z', '+00:00'))
            else:
                # Assume naive datetime is UTC
                dt = datetime.fromisoformat(datetime_str)
                dt = dt.replace(tzinfo=timezone.utc)
            
            formatted = dt.strftime('%Y-%m-%d %H:%M:%S UTC')
            
            if with_days_remaining:
                now = datetime.now(timezone.utc)
                days_remaining = (dt - now).days
                if dt > now:
                    formatted += f" [expires in {days_remaining} days]"
                else:
                    formatted += " [EXPIRED]"
            
            return formatted
        except Exception as e:
            # Fallback formatting - preserve original behavior but log what went wrong
            fallback = datetime_str[:19] + ' UTC' if len(datetime_str) >= 19 else datetime_str + ' UTC'
            if with_days_remaining:
                fallback += " [DATE PARSE ERROR]"
            return fallback

    def extract_file_details(self, obj_info: Dict[str, Any]) -> List[Tuple[str, str]]:
        """Extract common file details (name, size, permissions, modified time)"""
        details = []
        
        file_path = obj_info.get('file', '')
        if file_path:
            import os
            details.append(('File Name', os.path.basename(file_path)))

            # File size
            file_size = obj_info.get('file_size')
            if file_size:
                details.append(('File Size', self.format_file_size(file_size)))
            
            # File permissions
            file_perms = obj_info.get('file_permissions')
            if file_perms:
                details.append(('File Permissions', file_perms))
            
            # Last modified time
            last_modified = obj_info.get('last_modified')
            if last_modified:
                details.append(('File Modified', self.format_datetime(last_modified)))
        
        return details

    def print_file_info_tree(self, obj_info: Dict[str, Any], base_path: str, indent: str) -> None:
        """Print file information as tree branches at the end of entity details"""
        file_path = obj_info.get('file', '')
        if not file_path:
            return
            
        import os
        filename = os.path.basename(file_path)
        
        # Print "File" as main branch with [:] marker (header style)
        file_branch_path = f"{base_path} -> file"
        file_marker = self.get_change_marker_for_path(file_branch_path)
        
        # Use [:] for unchanged files, otherwise use change marker
        if file_marker in ['+', '-', '~']:
            file_color = self.get_change_color_for_path(file_branch_path)
            file_display = f"[{file_marker}] File"
        else:
            file_color = Colors.BOLD + Colors.WHITE
            file_display = f"[:] File"
        
        file_display = self.colorize(file_display, file_color)
        print(f"{indent}└──{file_display}")
        
        # Print file details as sub-branches
        file_details = []
        
        # File name
        file_details.append(('name', filename))
        
        # Full absolute path
        file_details.append(('path', file_path))
        
        # File size
        file_size = obj_info.get('file_size')
        if file_size is not None:
            file_details.append(('size', self.format_file_size(file_size)))
        
        # File permissions in octal format
        file_perms = obj_info.get('file_permissions')
        if file_perms:
            # Convert to octal format if it's not already
            if file_perms.startswith('0o') or file_perms.startswith('0'):
                octal_perms = file_perms
            else:
                # Assume it's a string like "rw-r--r--" and try to convert
                try:
                    # If it looks like Unix permissions, convert to octal
                    if len(file_perms) == 9 and all(c in 'rwx-' for c in file_perms):
                        octal_val = 0
                        for i, perm in enumerate(file_perms):
                            if perm != '-':
                                octal_val |= (1 << (8 - i))
                        octal_perms = f"0o{oct(octal_val)[2:]:0>3}"
                    else:
                        octal_perms = file_perms
                except:
                    octal_perms = file_perms
            file_details.append(('permissions', octal_perms))
        
        # Last modified time
        last_modified = obj_info.get('last_modified')
        if last_modified:
            file_details.append(('modified', self.format_datetime(last_modified)))
        
        # Print each detail as a sub-branch
        sub_indent = indent + "    "
        for i, (detail_type, detail_value) in enumerate(file_details):
            is_last_detail = (i == len(file_details) - 1)
            detail_path = f"{file_branch_path} -> {detail_type}"
            detail_marker = self.get_change_marker_for_path(detail_path)
            detail_color = self.get_change_color_for_path(detail_path)
            
            detail_display = f"[{detail_marker}] {detail_type.title()}: {detail_value}"
            if detail_marker in ['+', '-', '~']:
                detail_display = self.colorize(detail_display, detail_color)
            
            branch_symbol = "└──" if is_last_detail else "├──"
            print(f"{sub_indent}{branch_symbol}{detail_display}")

    def print_details_with_file_info(self, details: List[Tuple[str, str]], obj_info: Dict[str, Any], base_path: str, indent: str) -> None:
        """Print entity details followed by file information with correct tree structure"""
        has_file_info = bool(obj_info.get('file'))
        
        # Print regular details
        for i, (label, value) in enumerate(details):
            is_last_detail = (i == len(details) - 1)
            detail_path = f"{base_path} -> {label.lower().replace(' ', '_').replace('&', 'and')}"
            detail_marker = self.get_change_marker_for_path(detail_path)
            detail_color = self.get_change_color_for_path(detail_path)
            
            # If this is the last detail AND there's file info, use junction (├) not corner (└)
            if is_last_detail and has_file_info:
                branch = "├──"
            else:
                branch = "└──" if is_last_detail else "├──"
            
            detail_display = f"[{detail_marker}] {label}: {value}"
            
            if detail_marker in ['+', '-', '~']:
                detail_display = self.colorize(detail_display, detail_color)
            
            print(f"{indent}{branch}{detail_display}")
        
        # Print file information if it exists
        if has_file_info:
            self.print_file_info_tree(obj_info, base_path, indent)

    def print_details_tree(self, details: List[Tuple[str, str]], base_path: str, indent: str) -> None:
        """Print a list of details as tree sub-elements with proper formatting"""
        for i, (label, value) in enumerate(details):
            is_last = (i == len(details) - 1)
            detail_path = f"{base_path} -> {label.lower().replace(' ', '_').replace('&', 'and')}"
            detail_marker = self.get_change_marker_for_path(detail_path)
            detail_color = self.get_change_color_for_path(detail_path)
            
            branch = "└──" if is_last else "├──"
            detail_display = f"[{detail_marker}] {label}: {value}"
            
            if detail_marker in ['+', '-', '~']:
                detail_display = self.colorize(detail_display, detail_color)
            
            print(f"{indent}{branch}{detail_display}")

    def format_tree_item(self, marker: str, label: str, count: int = None) -> str:
        """Format a tree item with marker and optional count"""
        if count is not None:
            return f"[{marker}] {label} ({count})"
        else:
            return f"[{marker}] {label}"

    def get_tree_branch(self, indent: str, is_last: bool) -> Tuple[str, str]:
        """Get the appropriate tree branch symbols and next indent level"""
        if indent == "":
            branch = " ├──" if not is_last else " └──"
            next_indent = " │   " if not is_last else "     "
        else:
            branch = indent + ("├──" if not is_last else "└──")
            next_indent = indent + ("│   " if not is_last else "    ")
        return branch, next_indent

    def format_tree_node(self, path: str, label: str, color: str = None) -> str:
        """Format a tree node with marker and color"""
        marker = self.get_change_marker_for_path(path)
        node_color = self.get_change_color_for_path(path) if marker in ['+', '-', '~'] else (color or Colors.RESET)
        display = f"[{marker}] {label}"
        return self.colorize(display, node_color) if node_color != Colors.RESET else display

    def format_sub_header_node(self, path: str, label: str) -> str:
        """Format a sub-header node (Certificate, CSR, Private Key) with [:] marker and white-bold color"""
        marker = self.get_change_marker_for_path(path)
        # Use change color if there's a change, otherwise use white-bold
        if marker in ['+', '-', '~']:
            node_color = self.get_change_color_for_path(path)
        else:
            marker = ":"  # Use colon for unchanged sub-headers
            node_color = Colors.BOLD + Colors.WHITE
        
        display = f"[{marker}] {label}"
        return self.colorize(display, node_color)

    def print_tree_section(self, indent: str, is_last: bool, path: str, label: str, count: int = None, default_color: str = Colors.BOLD + Colors.WHITE):
        """Print a tree section header with formatting"""
        section_marker = self.get_change_marker_for_path(path)
        section_color = self.get_change_color_for_path(path) if section_marker in ['+', '-', '~'] else default_color
        display = self.format_tree_item(section_marker if section_marker in ['+', '-', '~'] else ":", label, count)
        
        branch = indent + ("└──" if is_last else "├──")
        print(f"{branch}{self.colorize(display, section_color)}")
        
        return indent + ("    " if is_last else "│   ")

    def process_sub_items(self, cert_data: Dict[str, Any], cert_path: str, cert_details_indent: str):
        """Process and display sub-items (certificate, CSR, private key) for an issued certificate"""
        sub_items = []
        cert_info = cert_data.get('certificate')
        csr_info = cert_data.get('certificate_signing_request')  
        private_key_info = cert_data.get('private_key')
        
        if cert_info:
            sub_items.append(('certificate', cert_info, 'Certificate'))
        if csr_info:
            sub_items.append(('csr', csr_info, 'Certificate Signing Request'))
        if private_key_info:
            sub_items.append(('private_key', private_key_info, 'Private Key'))

        for sub_idx, (sub_type, sub_data, sub_label) in enumerate(sub_items):
            is_last_sub = (sub_idx == len(sub_items) - 1)
            sub_path = f"{cert_path} -> {sub_type}"
            
            sub_display = self.format_sub_header_node(sub_path, sub_label)
            sub_branch = cert_details_indent + ("└──" if is_last_sub else "├──")
            print(f"{sub_branch}{sub_display}")
            
            # Print details as sub-sub-elements
            sub_detail_indent = cert_details_indent + ("    " if is_last_sub else "│   ")
            if sub_type == 'certificate':
                self.print_certificate_details(sub_data, sub_path, sub_detail_indent)
            elif sub_type == 'private_key':
                self.print_private_key_details(sub_data, sub_path, sub_detail_indent)
            elif sub_type == 'csr':
                self.print_csr_details(sub_data, sub_path, sub_detail_indent)

    def print_ca_sections(self, ca_data: Dict[str, Any], current_path: str, next_indent: str):
        """Print sections for a CA (certificate, private key, CSR, child authorities, issued certificates)"""
        own_cert = ca_data.get('own_certificate')
        own_key = ca_data.get('own_private_key')
        own_csr = ca_data.get('own_certificate_signing_request')
        issued_certs = ca_data.get('issued_certificates', {})
        child_authorities = ca_data.get('authorities', {})
        
        # Count and display sections - fix path names for consistency with original format
        sections = []
        if own_cert:
            sections.append(('own_certificate', own_cert, 'Certificate'))
        if own_csr:
            sections.append(('own_certificate_signing_request', own_csr, 'Certificate Signing Request'))
        if own_key:
            sections.append(('own_private_key', own_key, 'Private Key'))
        if child_authorities:
            sections.append(('authorities', child_authorities, 'Certificate Authorities'))
        if issued_certs:
            sections.append(('issued_certificates', issued_certs, 'Issued Certificates'))
        
        for section_idx, (section_type, section_data, section_label) in enumerate(sections):
            is_last_section = (section_idx == len(sections) - 1)
            section_path = f"{current_path} -> {section_type}"
            
            if section_type == 'authorities':
                section_indent = self.print_tree_section(next_indent, is_last_section, section_path, section_label, len(section_data))
                self.print_ca_tree(section_data, section_indent, True, section_path)
            elif section_type == 'issued_certificates':
                section_indent = self.print_tree_section(next_indent, is_last_section, section_path, section_label, len(section_data))
                self.print_issued_certificates(section_data, section_path, section_indent)
            else:
                # Individual items (certificate, key, csr) - use sub-header formatting
                section_display = self.format_sub_header_node(section_path, section_label)
                section_branch = next_indent + ("└──" if is_last_section else "├──")
                print(f"{section_branch}{section_display}")
                
                section_detail_indent = next_indent + ("    " if is_last_section else "│   ")
                if section_type == 'own_certificate':
                    self.print_certificate_details(section_data, section_path, section_detail_indent)
                elif section_type == 'own_private_key':
                    self.print_private_key_details(section_data, section_path, section_detail_indent)
                elif section_type == 'own_certificate_signing_request':
                    self.print_csr_details(section_data, section_path, section_detail_indent)

    def print_issued_certificates(self, issued_certs: Dict[str, Any], issued_path: str, cert_section_indent: str):
        """Print issued certificates section"""
        for j, (cert_name, cert_data) in enumerate(sorted(issued_certs.items())):
            is_last_cert = (j == len(issued_certs) - 1)
            cert_path = f"{issued_path} -> {cert_name}"
            cert_type = cert_data.get('type', 'unknown')
            
            cert_display = self.format_tree_node(cert_path, f"{cert_name} [{cert_type}]", Colors.BLUE)
            cert_branch = cert_section_indent + ("└──" if is_last_cert else "├──")
            print(f"{cert_branch}{cert_display}")
            
            # Show certificate, private key, and CSR as sub-elements
            cert_details_indent = cert_section_indent + ("    " if is_last_cert else "│   ")
            self.process_sub_items(cert_data, cert_path, cert_details_indent)

    def format_detailed_csr_info(self, csr_info: Dict[str, Any]) -> str:
        """Format detailed CSR information for diff display"""
        if 'error' in csr_info:
            return f"[ERROR: {csr_info.get('error', 'Unknown error')}]"
        
        parts = []
        
        # Subject
        subject = csr_info.get('subject', 'Unknown Subject')
        parts.append(f"Subject: {subject}")
        
        # Key information
        key_size = csr_info.get('public_key_size')
        sig_alg = csr_info.get('signature_algorithm', '')
        if key_size and sig_alg:
            parts.append(f"Key: {key_size}-bit {sig_alg}")
        
        # File location
        file_path = csr_info.get('file', '')
        if file_path:
            import os
            parts.append(f"File: {os.path.basename(file_path)}")
        
        return "; ".join(parts)
    
    def print_certificate_details(self, cert_info: Dict[str, Any], base_path: str, indent: str) -> None:
        """Print certificate details as tree sub-elements"""
        if not cert_info or 'error' in cert_info:
            error_msg = cert_info.get('error', 'Unknown error') if cert_info else 'No certificate data'
            print(f"{indent}├── [!] ERROR: {error_msg}")
            return
        
        details = []
        
        # Subject
        subject = cert_info.get('subject', 'Unknown Subject')
        if subject:
            details.append(('Subject', subject))
        
        # Issuer (only if different from subject)
        issuer = cert_info.get('issuer', 'Unknown Issuer')
        is_self_signed = cert_info.get('is_self_signed', subject == issuer)
        if not is_self_signed:
            details.append(('Issuer', issuer))
        else:
            details.append(('Type', 'Self-signed'))
        
        # Certificate type
        cert_type = cert_info.get('cert_type', '')
        if cert_type:
            details.append(('Cert Type', cert_type.upper().replace('_', ' ')))
        
        # Serial number (full)
        serial = cert_info.get('serial_number', '')
        if serial:
            details.append(('Serial', serial))
        
        # Validity period - separate Valid from and Valid till
        not_before = cert_info.get('not_valid_before', '')
        not_after = cert_info.get('not_valid_after', '')
        if not_before:
            details.append(('Valid from', self.format_datetime(not_before)))
        
        if not_after:
            details.append(('Valid till', self.format_datetime(not_after, with_days_remaining=True)))
        
        # Key information
        key_size = cert_info.get('public_key_size')
        sig_alg = cert_info.get('signature_algorithm', '')
        if key_size or sig_alg:
            key_str = f"{key_size}-bit" if key_size else ""
            if sig_alg:
                key_str += f" {sig_alg}" if key_str else sig_alg
            details.append(('Key', key_str))
        
        # Fingerprint
        fingerprint = cert_info.get('fingerprint_sha256', '')
        if fingerprint:
            fp_short = fingerprint[:16] + '...' if len(fingerprint) > 16 else fingerprint
            details.append(('SHA256', fp_short))
        
        # Certificate modulus (for RSA certificates)
        cert_modulus = cert_info.get('public_modulus', '')
        if cert_modulus:
            modulus_str = str(cert_modulus)
            if len(modulus_str) > 32:
                modulus_display = f"{modulus_str[:16]}...{modulus_str[-16:]}"
            else:
                modulus_display = modulus_str
            details.append(('Modulus', modulus_display))
        
        # Subject Alternative Names
        sans = cert_info.get('subject_alternative_names', [])
        if sans:
            if len(sans) <= 3:
                details.append(('SANs', ', '.join(sans)))
            else:
                details.append(('SANs', f"{', '.join(sans[:3])} (+{len(sans)-3} more)"))
        
        # Certificate usage type (server, client, server_client) and key usage info
        key_usage = cert_info.get('key_usage', [])
        ext_key_usage = cert_info.get('extended_key_usage', [])
        basic_constraints = cert_info.get('basic_constraints', {})
        
        # Determine certificate usage type
        if basic_constraints.get('ca'):
            cert_usage_type = "CA"
            path_len = basic_constraints.get('path_length')
            if path_len is not None:
                cert_usage_type += f" (pathlen={path_len})"
        else:
            has_server = 'server_auth' in ext_key_usage
            has_client = 'client_auth' in ext_key_usage
            has_digital_sig = 'digital_signature' in key_usage
            has_key_enc = 'key_encipherment' in key_usage
            
            if has_server and has_client:
                cert_usage_type = "server_client"
            elif has_server or has_key_enc:
                cert_usage_type = "server"
            elif has_client or has_digital_sig:
                cert_usage_type = "client"
            else:
                cert_usage_type = "unknown"
        
        details.append(('Usage Type', cert_usage_type))
        
        # Key Usage
        if key_usage:
            details.append(('Key Usage', ', '.join(key_usage)))
        
        # Extended Key Usage
        if ext_key_usage:
            details.append(('Ext Key Usage', ', '.join(ext_key_usage)))
        
        # Basic Constraints (for CA certificates)
        if basic_constraints.get('ca'):
            bc_str = "CA=true"
            path_len = basic_constraints.get('path_length')
            if path_len is not None:
                bc_str += f", pathlen={path_len}"
            details.append(('Basic Constraints', bc_str))
        
        # Print all details with file information using correct tree structure
        self.print_details_with_file_info(details, cert_info, base_path, indent)
    
    def print_private_key_details(self, key_info: Dict[str, Any], base_path: str, indent: str) -> None:
        """Print private key details as tree sub-elements"""
        if not key_info or 'error' in key_info:
            error_msg = key_info.get('error', 'Unknown error') if key_info else 'No private key data'
            print(f"{indent}├── [!] ERROR: {error_msg}")
            return
        
        details = []
        
        # Key type and size
        key_type = key_info.get('key_type', 'Unknown')
        key_size = key_info.get('size') or key_info.get('key_strength')
        if key_size:
            details.append(('Type & Size', f"{key_size}-bit {key_type}"))
        elif key_type != 'Unknown':
            details.append(('Type', key_type))
        
        # Encryption status
        encrypted = key_info.get('encrypted', False)
        has_passphrase = key_info.get('has_passphrase_file', False)
        if encrypted:
            enc_str = "Encrypted"
            if has_passphrase:
                enc_str += " (passphrase file exists)"
            details.append(('Encryption', enc_str))
        else:
            details.append(('Encryption', "Unencrypted"))
        
        # Public exponent (for RSA keys)
        pub_exp = key_info.get('public_exponent')
        if pub_exp and key_type == 'RSA':
            details.append(('Public Exponent', str(pub_exp)))
        
        # Curve (for EC keys)
        curve = key_info.get('curve')
        if curve:
            details.append(('Curve', curve))
        
        # Modulus (for RSA keys)
        modulus = key_info.get('public_modulus', '')
        if modulus:
            modulus_str = str(modulus)
            if len(modulus_str) > 32:
                modulus_display = f"{modulus_str[:16]}...{modulus_str[-16:]}"
            else:
                modulus_display = modulus_str
            details.append(('Modulus', modulus_display))
        
        # Print all details with file information using correct tree structure
        self.print_details_with_file_info(details, key_info, base_path, indent)
    
    def print_csr_details(self, csr_info: Dict[str, Any], base_path: str, indent: str) -> None:
        """Print CSR details as tree sub-elements"""
        if not csr_info or 'error' in csr_info:
            error_msg = csr_info.get('error', 'Unknown error') if csr_info else 'No CSR data'
            print(f"{indent}├── [!] ERROR: {error_msg}")
            return
        
        details = []
        
        # Subject
        subject = csr_info.get('subject', 'Unknown Subject')
        if subject:
            details.append(('Subject', subject))
        
        # Public key information
        key_size = csr_info.get('public_key_size')
        sig_alg = csr_info.get('signature_algorithm', '')
        pub_key_type = csr_info.get('public_key_type', '')
        if key_size or sig_alg:
            key_str = f"{key_size}-bit" if key_size else ""
            if pub_key_type:
                key_str += f" {pub_key_type}" if key_str else pub_key_type
            if sig_alg:
                key_str += f" {sig_alg}" if key_str else sig_alg
            details.append(('Key', key_str))
        
        # Subject Alternative Names
        sans = csr_info.get('subject_alternative_names', [])
        if sans:
            if len(sans) <= 3:
                details.append(('SANs', ', '.join(sans)))
            else:
                details.append(('SANs', f"{', '.join(sans[:3])} (+{len(sans)-3} more)"))
        
        # Key Usage
        key_usage = csr_info.get('key_usage', [])
        if key_usage:
            details.append(('Key Usage', ', '.join(key_usage)))
        
        # Extended Key Usage
        ext_key_usage = csr_info.get('extended_key_usage', [])
        if ext_key_usage:
            details.append(('Ext Key Usage', ', '.join(ext_key_usage)))
        
        # Print all details with file information using correct tree structure
        self.print_details_with_file_info(details, csr_info, base_path, indent)
    
    def print_ca_tree(self, authorities: Dict[str, Any], indent: str = "", is_last: bool = True, ca_path: str = "authorities") -> None:
        """Recursively print the CA tree structure with change highlighting and bracketed markers"""
        
        # At the root level, print the Certificate Authorities header
        if indent == "":
            header_display = self.format_tree_item(":", "Certificate Authorities", len(authorities))
            authorities_marker = self.get_change_marker_for_path(ca_path)
            header_color = self.get_change_color_for_path(ca_path) if authorities_marker in ['+', '-', '~'] else Colors.BOLD + Colors.WHITE
            print(self.colorize(header_display, header_color))
        
        for i, (ca_name, ca_data) in enumerate(sorted(authorities.items())):
            is_last_ca = (i == len(authorities) - 1)
            current_path = f"{ca_path} -> {ca_name}"
            
            # Determine the tree symbols
            branch, next_indent = self.get_tree_branch(indent, is_last_ca)
            
            # Format CA name with bracketed marker
            ca_display = self.format_tree_node(current_path, ca_name, Colors.BOLD + Colors.BLUE)
            print(f"{branch}{ca_display}")
            
            # Print all sections for this CA
            self.print_ca_sections(ca_data, current_path, next_indent)
    
    def print_pki_tree(self, state: Dict[str, Any], title: str) -> None:
        """Print the full PKI tree structure"""
        print(self.colorize(f"PKI Structure - {title}", Colors.BOLD + Colors.CYAN))
        print()

        authorities = state.get('authorities', {})
        if not authorities:
            print("No authorities found")
            return
        
        self.print_ca_tree(authorities)
        print()  # Empty line after tree
    
    def compare_states(self, before_file: str, after_file: str) -> bool:
        """Main method to compare two state files"""
        # Load the JSON files
        before_state = self.load_json_file(before_file)
        after_state = self.load_json_file(after_file)
        
        # Print header
        self.print_header(before_file, after_file)
        
        # Compare the states
        self.compare_values(before_state, after_state, [])
        
        # Print "After" tree with change markers
        self.print_pki_tree(after_state, "AFTER (with changes highlighted)")
        
        # Print traditional diff output
        if self.differences:
            self.print_differences()
        
        self.print_summary()
        
        # Return True if there are differences
        return len(self.differences) > 0


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="Compare two PKI state JSON dumps and show differences",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python scripts/state_compare.py /tmp/pki_state/before.json /tmp/pki_state/after.json
  python scripts/state_compare.py --no-color state1.json state2.json > diff.txt
        """
    )
    
    parser.add_argument("before", 
                       help="Path to the 'before' state JSON file")
    parser.add_argument("after", 
                       help="Path to the 'after' state JSON file")
    parser.add_argument("--no-color", action="store_true",
                       help="Disable colored output")
    
    args = parser.parse_args()
    
    # Validate file paths
    if not Path(args.before).exists():
        print(f"Error: Before file '{args.before}' does not exist", file=sys.stderr)
        sys.exit(1)
        
    if not Path(args.after).exists():
        print(f"Error: After file '{args.after}' does not exist", file=sys.stderr)
        sys.exit(1)
    
    # Create comparator and run comparison
    use_colors = not args.no_color and sys.stdout.isatty()
    comparator = StateComparator(use_colors=use_colors)
    
    try:
        has_differences = comparator.compare_states(args.before, args.after)
        # Exit with code 1 if there are differences (similar to diff command)
        sys.exit(1 if has_differences else 0)
    except Exception as e:
        print(f"Error: Failed to compare states: {e}", file=sys.stderr)
        sys.exit(2)


if __name__ == "__main__":
    main()